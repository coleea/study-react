
## 리액트 18 관련

### 컨커런트 모드 (cuncurrent mode)

컨커런트 모드는 그저 서스펜스 컴포넌트를 사용하는 환경을 지칭할 뿐이다. 모든것이 서스펜스 컴포넌트가 있어야 수행될 수 있다.\
\
서스펜스 컴포넌트는 컴포넌트의 지연 렌더링에 사용하는 랩퍼 컴포넌트다


##### 서스펜스(suspense) 모드 (suspense, concurrent mode, SSR Streaming)
Concurrent features in React 18 include built-in support for server-side Suspense and SSR streaming support, allowing you to server-render pages using HTTP streaming.
[출처](https://nextjs.org/docs/advanced-features/react-18)

This also means that you can use Suspense-based data-fetching, next/dynamic, and React's built-in React.lazy with Suspense boundaries.

### 서스펜스(suspense) 컴포넌트

### 서스펜스리스트(SuspenseList) 컴포넌트

### Q. useTransition이란 무엇인가 ?

유즈 트랜지션은 서스펜스 컴포넌트의 fallback을 보여주지 않기위한 용도로 고안되었다\
\
화면이 다른 화면으로 전환될 때 화면에 나타나는 변화를 지연하고 싶은 경우에 사용한다. `React.lazy()`가 떠오른다면 정상이다\
\
실제로 서스펜스 컴포넌트 내부에서 리액트 레이지를 호출하는 방식으로 내부가 구현되어 있다\
\
먼저 유즈트랜지션을 사용하려면 가상돔을 렌더링 할 때 `ReactDom.render()` 대신에 `ReactDOM.createRoot()` 메소드를 사용해야 한다. \
\
크리에이트 루트라는 메소드는 생소하겠지만 이것을 호출해야 `컨커런트 모드`로 실행할 수 있다. 컨커런트 모드와 일반 모드는 리액트 스케줄러의 작동 메커니즘이 다르다\
\
그러니 이제는 ReactDOM.render()뿐만이 아니라 ReactDOM.createRoot()메소드에 익숙해지는 편이 좋다. 앞으로도 자주 보게 될 것이다\
\
유즈트랜지션의 문법은 아래와 같다

```javascript
const [startTransition, isPending] = useTransition({timeoutMs: 5000});
```

useTransition은 인자로 객체를 받는다. 객체는 timeoutMs를 프로퍼티로 가지는데 이 값은 트랜지션이 완료될 때까지 인내할 수 있는 시간이다.\
\
위의 예제에서는 값이 3000인데 이 말은 3000ms 즉 3초까지는 이전화면을 보여주고 만일 3초가 지났다면 로딩바를 보여주라는 뜻이다.\
\
즉 useTransition은 트랜지션 효과를 최대한 지연하고 싶을 때 사용하는 함수다.\
\
그러므로 useTransition보다는 useTransitionDelay라고 하는편이 더 정확하다. 어쩃든 로딩 상태창 등을 보여주고 싶지 않은 상황에 쓰이는 것이다.\
\
useTransition 훅은 배열을 리턴하는데 첫번째 원소를 startTransition 함수라고 한다. 그리고 두번째 원소를 isPending 변수라고 한다.\
\
먼저 간단한 isPending부터 설명하면 isPending은 이름이 시사하는 것처럼 불린 값이다. 트랜지션 상태가 펜딩(pending) 상태인지 리시디드(receded) 상태인지 여부를 알 수 있다. 펜딩 상태는 그저 트랜지션이 완료될 때 까지 기다리고 있는 상태다.\
\
startTransition 함수는 인자로 콜백을 받는다. 이 콜백 내부에서 setState류의 상태변화 함수를 호출하는데 이 상태변화에 반응하는 컴포넌트가 서스펜스 컴포넌트의 자식이라면 서스펜스 컴포넌트는 지정한 타임아웃 만료하기 전까지 fallback 엘리먼트를 보여주지 않는다.\
\
이것은 일반적인 서스펜스의 작동방식과 정 반대라고 볼 수 있다. 서스펜스 컴포넌트는 본래 로딩하는 과정에서 유저가 지루해하지 않도록 로딩 화면을 보여주려는 의도로 고안되었다. useTransition훅은 서스펜스 본래의 의도와는 정 반대의 작동을 수행하도록 유도하는 것이다\
\
유저가 로딩 시간을 참지 못하고 이탈할 수도 있을텐데 왜 로딩바를 보여주려 하지 않을까 ?  사실 로딩바를 보여주고 싶지 않은 상황이 있다\
\
이미 웹 페이지에 로딩 중에도 소비할 수 있는 충분한 컨텐츠가 있어서 오히려 로딩이라는 메시지가 방해로 작용하는 상황이 존재하는 것이다. 유즈트랜지션은 이런 상황에 쓰인다\
\
그러나 인내심에도 한계가 있는 것이어서 어떤 화면 전환이 너무 느릴 경우에는 유저가 짜증이 날 수 있다. 그래서 트랜지션에 최대 마감시간을 설정해 놓고 그 시간까지도 트랜지션이 완료되지 않는다면 그제서야 fallback을 보여주는 것이다.\
\
여담으로 서스펜스 컴포넌트에 `isFallback=false` 라는 식의 어트리뷰를 지정하는 편이 더 사용하기 수월하지 않겠나 싶지만 어째서인지 이렇게 하지 않고 `useTransition` 훅으로 이를 구현한 것으로 보인다.

[참고](https://ko.reactjs.org/docs/concurrent-mode-patterns.html)

#### Q. 유즈트랜지션 훅에서 리시디드(receded) 상태가 무엇인가 ?
A. 그건 모르겠고 상태가 `Receded → Skeleton → Complete`로 변한다는 건 안다
recede는 `서서히 물러나다`라는 뜻이다. fetch와 관련해서 서서히 물러나다 라는 뜻을 유추해보면 답을 알 수 있지 않을까 ?

##### 코드 분할과 레이지 로딩 (code spliting, lazy loading)

React.lazy를 사용하면 SSR 스트리밍(Streaming)이 가능해진다
`const LazyComponent = React.lazy(() => import('./OtherComponent'));`
React.lazy는 import()를 호출하는 함수를 인자로 r가진다. 이 함수는 프로미스를 반환한다
그렇게 생성된 레이지 컴포넌트는 아래와 같은 구문에서 사용된다

```javascript
<Suspense fallback={<div>Loading...</div>}>
    <LazyComponent />
</Suspense>
```

위의 suspense 컴포넌트는 레이지 로딩을 가능하게 해준다. 서버에 컴포넌트를 요청하는 동안은 fallback 어트리뷰트의 html 코드를 렌더링하고 컴포넌트 요청이 완료되면 해당 컴포넌트를 렌더링한다\
\
[링크](https://ko.reactjs.org/docs/context.html)

[링크](https://ko.reactjs.org/docs/code-splitting.html)

[공식홈페이지 문서](https://reactjs.org/docs/concurrent-mode-intro.html)

 hydrate과정이 블로킹을 유발하는 현상을 방지하는 것은 리액트의 오랜 숙제였다.

 약 1000여개가 넘는 html 엘리먼트를 논스톱으로 한번에 하이드레이트 하는 행위는 렌더러 스레드가 자바스크립트 실행 엔진에 의해 장시간 선점되는 결과를 초래한다. 이 상황은 페이지가 프리징되는 현상을 야기하여 사용자 경험을 저하시킨다.

 이런 문제는 하이드레이트 작업이 소규모 테스크 단위로 분리되지 않기 때문에 발생했다.

 그래서 사람들은 하이드레이션 작업을 다중 테스크로 분해하는 방법을 모색했다.

 이러한 하이드레이션 테크닉을 progressive hydration 또는 incremental hydration이라고 부른다.

 이러한 테크닉을 구현하는 방법은 여러가지가 있겠으나 리액트는 streaming SSR을 구현하면서 덤으로 이 문제를 (어느정도) 해결했다.

 streaming SSR은 대단히 단순한 컨셉으로부터 출발한다. html데이터를 한번에 전송하는 대신 컴포넌트 레벨로 분해하여 여러번에 걸쳐 순차적으로 전송하는 것이 핵심 아이디어인데 이렇게 할 경우 다방면에 걸쳐 유리하다.

 첫째로 서버측에서 클라이언트에게 데이터를 전송하는 딜레이, 다시말해 Time To First Byte(TTFB)를 줄일 수 있다. 이는 서버측에서 DB요청에 대한 응답을 기다리지 않고 가장 먼저 렌더링할 HTML 컴포넌트를 즉각적으로 클라이언트에게 전송하기 때문에 가능하다. DB요청이 완료되면 해당 DB와 관련된 HTML엘리먼트를 뒤이어 전송하면 되므로 아무런 문제가 없다.

 두번째로 클라이언트 측에서 렌더링을 수행하는 속도가 빨라진다. 이는 직관적으로 이해가 가능한 대목인데 부분적인 HTML엘리먼트를 렌더링하는 과정에서 렌더러 스레드가 렌더 트리를 생성하는데 걸리는 시간을 단축할 수 있기 때문이다.
 연산에 필요한 데이터가 그만큼 적으므로 이것은 당연하다.

 세번째는 incremental hydration으로 인한 이점인데, 전체 html파일이 아닌 html 컴포넌트 단위로 하이드레이션을 수행하기 자연스러운 환경이 조성된다. 만일 streaming SSR이 다층 레이어로 구성되어 단일 하이드레이션 테스크의 수행시간이 충분히 짦다면 하이드레이션 과정에서 웹페이지가 프리징되는 상황을 방지할 수 있다.

 여기까지가 streaming SSR 및 incremental hydration을 도입함으로서 얻을 수 있는 이익이었다. 이 주제에 관심이 있으면 댄 아브라모프가 작성한 https://lnkd.in/g23M7Hn 을 참조하는 것이 이해에 많은 도움을 줄 것이다.

그 외에 partial hydration이라는 개념도 눈여겨볼만 한데 이는 전체 html이 아닌 이벤트가 발생하는 html컴포넌트만을 하이드레이션 하는 기법이다.
 이를 적용하면 하이드레이션 타임이 줄어든다는 이점 외에도 가상DOM이 diff알고리즘을 수행하는 시간이 단축된다는 이점이 추가된다.

[출처](https://nextjs.org/docs/advanced-features/react-18)
상세는 [이 동영상](https://www.youtube.com/watch?v=TQQPAU21ZUw)을 참조하시오

### Q. 서버 컴포넌트 (Server Components)란 무엇인가 ?
먼저 헷갈릴 수 있는 개념인 서버 컴포넌트와 서버사이드 렌더링에 대해 짚고 넘어가자. 서버 컴포넌트 서버사이드 렌더링과는 다른 개념이다.\
\
먼저 이 둘의 공통점부터 짚고 넘어가자. 서버사이드 렌더링과 서버 컴포넌트 모두 렌더링을 서버에서 수행한다.\
\
반면 서버사이드 렌더링이 클라이언트 사이드에서 컴포넌트 하이드레이션을 수행하지만 서버 컴포넌트는 하이드레이션을 수행하지 않는다. 즉 클라이언트 사이드는 서버 컴포넌트와 관련하여 어떠한 자바스크립트 코드도 가지고 있지 않게된다\
\
어떻게 하이드레이션을 수행하지 않고도 웹페이지가 리액트 기반으로 구동될 수 있을까? 이것은 해당 컴포넌트가 완전히 정적인 컴포넌트라면 가능한 일이다. 컴포넌트가 정적이라면 유저 이벤트에 반응할 일이 없다. 시간이 변함에 따라 상태가 바뀔 일도 없다. 따라서 html로 렌더링한 결과를 뿌려준 후에는 재랜더링할 필요가 없으므로 리액트가 코드를 관리할 필요도 없어진다\
\
이렇게 완전 정적인 컴포넌트를 제외하고 오로지 동적인 컴포넌트만을 하이드레이션 하는 전략을 파셜 하이드레이션(partial hydration)이라고 한다\
\
즉 서버 컴포넌트는 파셜 하이드레이션 전략의 구현체이다\
\
파셜 하이드레이션은 두가지 측면에서 유리하다. 먼저 html이 로드된 후에 추가적으로 컴포넌트를 하이드레이션 하는 시간이 줄어든다. 하이드레이션 대상이 되는 컴포넌트의 수가 줄어들었으므로 이것은 당연한 이야기다.\
\
이렇게 하이드레이션 시간이 줄어듦으로서 렌더러 스레드가 자바스크립트 실행 엔진에 선점되는 시간이 줄어든다\
\
렌더러 스레드가 자바스크립트 실행 엔진에 선점되는 동안은 웹페이지가 유저와의 상호작용 및 페이지 렌더링 작업이 올스탑되므로 이는 유저 입장에서 마치 페이지가 프리징 된것처럼 느껴지며 따라서 UX를 저하시킨다\
\
그러므로 파셜 하이드레이션을 적용하면 웹페이지의 최초 구동시에 프리징 시간을 줄이는 효과가 있다\
\
또한 서버 컴포넌트와 관련된 js코드를 다운받지 않으므로 js의 파싱에 소모되는 시간이 없어진다. 이 또한 마찬가지로 웹페이지의 최초 구동시에 프리징 시간을 줄이는 효과가 있다

### Q. 공유 컴포넌트 (Shared Components)란 무엇인가 ?

서버와 클라이언트 양측에서 하나의 컴포넌트를 공유할 때 이 대상이 되는 컴포넌트를 공유 컴포넌트라고 한다\
\
생소할 수 있는 개념이지만 하나씩 살펴보자. 먼저 서버와 클라이언트가 컴포넌트를 공유한다는게 무슨뜻인가 ?
\
클라이언트 사이드에서 컴포넌트가 작동하는 개념은 익숙하다. 이와 마찬가지로 서버에도 클라이언트 사이드에서 사용하는 것과 동일한 컴포넌트를 동기화하여 코드를 작동할 수 있다. 즉 이런 개념은 `코드 실행의 위임`에 바탕을 둔다. 본래대로라면 클라이언트 측에서 실행되어야 할 컴포넌트의 로직을 서버에 위임하여 서버에서 컴포넌트의 로직을 실행한다는 개념이다\
\
예를 들어보자. 아래는 카운터 컴포넌트의 (적당한) 구현체이다
```javascript
function 카운터(){
    const [카운트, 카운트업] = useState()
    return (
        <>
            <p>현재 카운트는 {카운트}입니다</p>
            <button onClick={_ => 카운트업(++카운트)}>    카운트업    </button>
        </>
    )
}
```

위의 예에서 버튼을 클릭하면 `카운트설정` 함수가 호출되어 상태값이 변경되고 재랜더링 작업이 수행되어 페이지가 갱신된다. 이런 일반적인 페이지 갱신 과정을 서버에 위임해 보자. 먼저 onClick을 클릭했을 때 상태변경 함수를 호출하지 않고 그 대신 서버에 요청을 날린다. 이 요청은 크게 3가지 정보를 포함한다
1. 컴포넌트의 이름
1. 이벤트의 종류
1. 현재상태

서버가 이 요청을 받으면 주어진 정보를 토대로 상태를 변경하고 재랜더링 작업을 `서버에서` 수행한다. 이렇게 랜더링된 최종 html 코드를 다시 클라이언트에게 응답하면 클라이언트가 전달받은 html코드를 렌더링한다. 이것이 공유 컴포넌트가 작동하는 개괄적인 흐름이다. 이 흐름을 적당한 수도 코드로 작성하면 대략 아래와 같다

```javascript
function 카운터(){
    const [카운트, 카운트업] = useState()

    async function 서버요청(){
        const {html문자열} = await fetch('서버URL/api/서버컴포넌트', {
            컴포넌트이름 : '카운터',
            이벤트종류 : '카운트업',
            매개변수 : 카운트,
        }).then(res => res.json())

        ReactDOM.부분렌더링({
            타겟컴포넌트 : 카운터,
            렌더링값 : html문자열,
        })
    }

    return (
        <>
            <p>현재 카운트는 {카운트}입니다</p>
            <button onClick={서버요청}>카운트업</button>
        </>
    )
}
```
### 이 문서는 작성중입니다
