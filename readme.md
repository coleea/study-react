# React Q&A

## 리액트란?
우리는 뮤테이션을 최소화하기를 원한다.
우리는 개념적인 단순함을 주는 무언가를 만들고 싶다.
(we want to minimize the amount of mutation
we want to build something that gives us the conceptual simplicity)\
\
-- 조던월크 (Jordan Walke, 리액트 창시자)
\
복잡성을 제어하는 것이 컴퓨터 프로그래밍의 본질이다\
-- 브라이언 커니핸 (Brian Wilson Kernighan)\
\
그리고 이것이 우리가 하려는 일이다\
-- Jim Sproch, 前 React Core Team\
\
이것이 리액트이다\
즉 리액트는 변이를 최소화하고 복잡성을 제거하기 위해 태어났다

---

## 훅(hook)이란 ?

훅은 함수형 컴포넌트에서 이펙트를 사용할 수 있도록 도와주는 툴이다\
\
훅을 사용하여 우리는 라이프사이클 메소드 이름에 기반한 코드를 만들지 않아도 되며 코드가 실제로 하는 일에 기초하여 코드를 분리할 수 있다.\
-- [Dan](https://www.youtube.com/watch?v=dpw9EHDh2bM) (44:17을 참조)\
훅은 관심사로 로직을 분리하는 것을 가능하게 했다\
\
커스텀 훅은 자신만의 추상화를 만들 수 있는 유연성을 준다.\
그것들은 당신의 리액트 컴포넌트 트리를 팽창시키지도 않으며 래퍼 지옥을 피하게 해준다\
(custom hooks give you the flexibility to create your own abstractions  they do not inflate your react component tree and avoid the wrapper hell)\
-- [Dan](https://www.youtube.com/watch?v=dpw9EHDh2bM) (53:24을 참조)

Q. useState의 두번째 리턴값인 setOOO을 호출하면 무슨일이 발생하는가?\
A. 스테이트를 업데이트하는 순간 함수컴포넌트의 리랜더링을 강제한다\
클래스 컴포넌트의 forceUpdate() 메소드가 했던 것과 똑같은 것을 수행한다.\
\
Q. 세터(setter)가 호출되면 해당 컴포넌트가 무조건 재랜더링되는가 ?\
A. 항상 재랜더링되는 건 아니다. 재랜더링 되는 조건이 있다.\
\
Q. 그 재랜더링 되는 조건이라는 건 업데이트된 상태가 이전 상태와 달라야 한다는 것인가?\
A. 상태가 같건 다르건 그건 중요하지 않다. 리액트는 상태 비교를 하지 않는다. 유일한 리랜더링 조건은 `함수 컴포넌트의 리턴값이 이전 리턴값과 다를때`만 재랜더링을 수행한다


## 빌트인 훅 관련


##### useState
useState는 배열을 리턴한다.\
흔한 구문인 `const [name, setName] = useState('')`  는 어레이 디컨스트럭팅이 적용된 문법이다\
`setOOOO`은 리액트에서 권장하는 함수명이지만 굳이 이 규칙을 따를 필요는 없다. `이름변경하기`같은 한글 함수를 적용해도 괜찮다. 실제로 중국인들은 중국어로 작성하는 경우가 많다\
너무 관례에 집착하다가는 실용성을 놓칠수 있다\
\
Q. useState의 setOOO에는 인자로 함수를 넣을수 있다. 인자로 값을 넣는것과 함수를 넣는것의 차이는 무엇인가?
A. 함수를 인자로 넣을경우 바로 직전에 변화된 값을 반영할 수 있다. 예를 들어보자
```javascript
const [counter, setCounter] = useState(0)
setCounter(counter + 1)
setCounter(counter + 1)
```
위의 예는 setCounter에 값을 인자로 넣은 예제이다. 이 코드의 결과를 예측해보자. 만일 코드가 동기적으로 수행된다고 가정하면 `counter + 1`이 두번 반영되었으므로 `0 -> 1 -> 2` 순으로 값이 갱신되어 최종적인 `counter` 상태의 값은 2라고 생각할 수 있다. 하지만 값은 1이다. 그 이유는 두 가지가 있다
1. setCounter가 비동기적으로 실행된다
1. setCounter가 비동기적으로 실행되는 과정에서 인자로 넘어간 값은 이전 문맥을 고려하지 않으며 오로지 주어진 인자만을 반영하여 상태 갱신에 적용한다. 다시말해 위의 예제에서 setCounter함수가 두 번 호출될 때 인자로 넘어가는 `counter + 1`의 값은 모두 동일하게 `0 + 1`이다. 따라서 `setCounter(counter + 1)`를 몇번 호출하건 관계없이 counter의 값은 1이 된다. 만일 내가 호출하는 횟수만큼 값을 반영하고 싶을때는 함수를 인자로 넣으면 된다. 예를들어 아래와 같다
```javascript
const [counter, setCounter] = useState(0)
setCounter((최신_counter) => {return 최신_counter + 1} )
setCounter((최신_counter) => {return 최신_counter + 1} )
```
위의 예제는 setCounter의 인자를 값에서 함수로 바꾸었다. 이때는 값을 적용할 때와 로직이 조금 달라진다. setCounter의 콜백으로 넘어간 함수는 인자를 받아서 실행되는데 이 값은 함수 컴포넌트 내에 정의된 counter의 값이 아닌 리액트에서 관리하는 상태값이다. 이 최신의 상태값을 인자로 받아서 상태변경을 수행한다. 그리고 이어지는 두번째 setCounter함수의 인자도 동일한 방식으로 처리된다. 두번째 setCounter함수의 콜백으로 넘어간 함수도 인자를 받아서 실행되는데 이 값은 함수 컴포넌트에 있던 counter변수의 값이 아니다. 리액트에서 관리하는 최신의 상태값이다. 두번째 setCounter가 상태변화를 적용하는 시점의 counter의 값은 1이다. 따라서 1을 인자로 받아 1+1을 했으므로 최종 상태값은 2가 된다.\


##### useEffect
useEffect의 인자로 async함수를 넘겨줄 수 없다. 따라서 useEffect의 인자로 넘겨진 함수에서 await구문을 사용할 수 없다. 따라서 `promise.then()`구문을 사용하거나 별도의 async 함수를 호출해야 한다\
\
흔히 쓰는 패턴으로 두번째 인자인 의존성 배열을 빈 배열([])을 넣는 경우가 많다. []는 “절대로 이 이펙트 함수를 갱신하지 말것”이라는 의미이므로 버그 가능성이 높다. 이펙트 함수는 바깥에 선언된 handleChange가 바뀌더라도 다시 호출되지 않는다.
그리고 handleChange는 다른 props나 상태를 참조할 수도 있다.
https://overreacted.io/ko/react-as-a-ui-runtime/\
\
React는 이펙트함수가 실행되도록 스케줄링하는 런타임으로 useEffect를 제공합니다.\
결국 useEffect의 목적은 IO에게 바인딩을 제공하는 것입니다\
\
##### Q. useEffect는 어떻게 구현되었나 ?
A. useEffect의 구현 디테일을 말하자면 이것은 사이드이펙트의 형태로 구현되었다. 구체적으로 말하면 전역 뮤테이션.\
\
하지만 꼭 그렇게 되어야 한다고 말하는 건 아니다. 만일 자바스크립트가 대수적 효과를 지원했다면  전역 뮤테이션 없이 이를 표현할 수 있었을 것
-- dan

##### useEffect는 정확히 언제 실행되는가 ?

유즈이펙트의 이펙트 함수는 렌더링 사이클이 완전히 종료된 이후에 실행된다

### useLayoutEffect

이펙트 함수가 리액트 스케줄러에 의해 비동기로 발생하는 것 과는 다르게 useLayoutEffect는 diff알고리즘이 종료되고 가상돔이 실제돔에 직접적인 변경을 가한 이후에 동기적으로 바로 실행된다\
즉 하나의 렌더링 사이클 과정이 진행되는 자바스크립트 코드에서 동기적으로 실행된다

##### context 컴포넌트
컨텍스트 컴포넌트는 `상태 끌어올리기(lift state up)`를 위한 솔루션이다\
두개의 컴포넌트가 부모-자식 관계가 아닌 상태에서 데이터를 공유할 때 공통의 조상에게 데이터를 위임하여 그 조상으로부터 데이터를 넘겨받는 패턴이다. 이 때 데이터를 가진 조상 컴포넌트는 최소 공통 조상에게 넘겨주는게 관례이다. 그 이유는 퍼포먼스 때문인데 컨텍스트 API가 루트 컴포넌트에 가깝게 위로 올라갈수록 렌더링 속도의 저하 문제가 있기 때문이다\
컨텍스트 API를 적용했다면 스테이트가 변경된 경우 이 스테이트를 렌더링하는 모든 컴포넌트가 재랜더링된다

[lift state up 참고](https://ko.reactjs.org/docs/lifting-state-up.html)

### useRef
useRef는 리액트에서 html엘리먼트에 접근할 때 사용한다. 리액트에서는 쿼리셀렉터(document.querySelector)같은 셀렉터 함수 대신 ref를 이용하여 html엘리먼트를 컨트롤한다.\
주로 스타일이나 어트리뷰트 값을 조작할 때 사용한다

### forwardRef
외부 컴포넌트에서 다른 컴포넌트에 속해있는 html 엘리먼트에 접근할 때 사용한다\
외부 컴포넌트에서 다른 컴포넌트의 렌더링 행위를 조작하나는 행위는 컴포넌트의 아이솔레이션을 위반한다. 하지만 편의성 등의 문제로 이런 상황이 필요할 때가 있다. 엘리먼트를 포커싱 하는 상황 등에서 필요하다.\
\
forwardRef는 고차 컴포넌트인데 즉 인자로 컴포넌트를 받아서 다른 컴포넌트를 리턴한다. 이때 반환된 컴포넌트는 props외에도 ref라는 두번째 파라메터를 받는다. 이 두번째 파라메터가 외부에서 주입받는 ref로서 활용된다

### useImperativeHandle

이름만 보고서는 사용법을 유추하기 어려운 `useImperativeHandle` 훅은 외부에서 전달받은 ref를 html엘리먼트에 직접적으로 쓰지않고 하나의 이벤트로서 활용하기 위해서 쓴다. 말이 어려운데 하나씩 풀어서 설명해보자\
\
만일 외부에서 전달받은 ref에 어떤 이벤트가 발생하면 그 이벤트를 이벤트리스너가 듣는다. 그 이벤트리스너의 이름이 useImperativeHandle이다.\
\
이벤트리스너가 특정한 이벤트를 감지하면 컴포넌트 내부에서 생성한 ref를 기반으로 html엘리먼트를 컨트롤한다\
\
이짓을 왜 하는가? 바로 외부에서 넘겨받은 ref에 컴포넌트의 통제권을 넘겨주지 않기 위해서이다.\
\
만일 외부에서 건내받은 ref가 내 컴포넌트에 이런저런 짓을 마음대로 할 수 있다면 단일 컴포넌트로서의 아이솔레이션이 훼손된다.\
\
그러므로 최대한 아이솔레이션을 유지하려면 최종적으로 특정 컴포넌트의 html을 조작하는 권한은 자기 자신이 가지고 있는편이 좋다. 이것을 가능하게 해주는 것이 useImperativeHandle이다.\
\
다시 말해서 useImperativeHandle은 엘리먼트의 조작 권한을 컴포넌트 자기자신이 보유하게 해준다

##### createPortal
```javascript
ReactDOM.createPortal(child, container)
```
현재의 돔트리 구조를 무시하고 전혀 다른곳에 있는 컴포넌트를 부모삼아 렌더링하는 패턴이다\
모달 등의 `position:absolute`속성을 가진 컴포넌트를 구현할 때 쓰인다\
첫 번째 인자는 렌더링할 타겟 컴포넌트이며 두번째 인자는 삽입되고자하는 부모 엘리먼트이다\
\
포탈은 클라이언트에서만 유효한 기능이며 서버용 기능은 아니다.\
왜냐하면 reactDOM.render()가 수행된 추가적으로 호출하는 기능이기 때문이다. 따라서 `react-dom/server` 내부에는 리액트 포털이 없다

---

## 리액트 18 관련

### useTransition

유즈 트랜지션은 서스펜스 컴포넌트의 fallback을 보여주지 않기위한 용도로 고안되었다\
\
화면이 다른 화면으로 전환될 때 화면에 나타나는 변화를 지연하고 싶은 경우에 사용한다. `React.lazy()`가 떠오른다면 정상이다\
\
실제로 서스펜스 컴포넌트 내부에서 리액트 레이지를 호출하는 방식으로 내부가 구현되어 있다\
\
먼저 유즈트랜지션을 사용하려면 가상돔을 렌더링 할 때 `ReactDom.render()` 대신에 `ReactDOM.createRoot()` 메소드를 사용해야 한다. \
\
크리에이트 루트라는 메소드는 생소하겠지만 이것을 호출해야 `컨커런트 모드`로 실행할 수 있다. 컨커런트 모드와 일반 모드는 리액트 스케줄러의 작동 메커니즘이 다르다\
\
그러니 이제는 ReactDOM.render()뿐만이 아니라 ReactDOM.createRoot()메소드에 익숙해지는 편이 좋다. 앞으로도 자주 보게 될 것이다\
\
유즈트랜지션의 문법은 아래와 같다

```javascript
const [startTransition, isPending] = useTransition({timeoutMs: 5000});
```

useTransition은 인자로 객체를 받는다. 객체는 timeoutMs를 프로퍼티로 가지는데 이 값은 트랜지션이 완료될 때까지 인내할 수 있는 시간이다.\
\
위의 예제에서는 값이 3000인데 이 말은 3000ms 즉 3초까지는 이전화면을 보여주고 만일 3초가 지났다면 로딩바를 보여주라는 뜻이다.\
\
즉 useTransition은 트랜지션 효과를 최대한 지연하고 싶을 때 사용하는 함수다.\
\
그러므로 useTransition보다는 useTransitionDelay라고 하는편이 더 정확하다. 어쩃든 로딩 상태창 등을 보여주고 싶지 않은 상황에 쓰이는 것이다.\
\
useTransition 훅은 배열을 리턴하는데 첫번째 원소를 startTransition 함수라고 한다. 그리고 두번째 원소를 isPending 변수라고 한다.\
\
먼저 간단한 isPending부터 설명하면 isPending은 이름이 시사하는 것처럼 불린 값이다. 트랜지션 상태가 펜딩(pending) 상태인지 리시디드(receded) 상태인지 여부를 알 수 있다. 펜딩 상태는 그저 트랜지션이 완료될 때 까지 기다리고 있는 상태다.\
\
startTransition 함수는 인자로 콜백을 받는다. 이 콜백 내부에서 setState류의 상태변화 함수를 호출하는데 이 상태변화에 반응하는 컴포넌트가 서스펜스 컴포넌트의 자식이라면 서스펜스 컴포넌트는 지정한 타임아웃 만료하기 전까지 fallback 엘리먼트를 보여주지 않는다.\
\
이것은 일반적인 서스펜스의 작동방식과 정 반대라고 볼 수 있다. 서스펜스 컴포넌트는 본래 로딩하는 과정에서 유저가 지루해하지 않도록 로딩 화면을 보여주려는 의도로 고안되었다. useTransition훅은 서스펜스 본래의 의도와는 정 반대의 작동을 수행하도록 유도하는 것이다\
\
유저가 로딩 시간을 참지 못하고 이탈할 수도 있을텐데 왜 로딩바를 보여주려 하지 않을까 ?  사실 로딩바를 보여주고 싶지 않은 상황이 있다\
\
이미 웹 페이지에 로딩 중에도 소비할 수 있는 충분한 컨텐츠가 있어서 오히려 로딩이라는 메시지가 방해로 작용하는 상황이 존재하는 것이다. 유즈트랜지션은 이런 상황에 쓰인다\
\
그러나 인내심에도 한계가 있는 것이어서 어떤 화면 전환이 너무 느릴 경우에는 유저가 짜증이 날 수 있다. 그래서 트랜지션에 최대 마감시간을 설정해 놓고 그 시간까지도 트랜지션이 완료되지 않는다면 그제서야 fallback을 보여주는 것이다.\
\
여담으로 서스펜스 컴포넌트에 `isFallback=false` 라는 식의 어트리뷰를 지정하는 편이 더 사용하기 수월하지 않겠나 싶지만 어째서인지 이렇게 하지 않고 `useTransition` 훅으로 이를 구현한 것으로 보인다.

[참고](https://ko.reactjs.org/docs/concurrent-mode-patterns.html)

##### 코드 분할과 레이지 로딩 (code spliting, lazy loading)

React.lazy를 사용하면 SSR 스트리밍(Streaming)이 가능해진다
`const LazyComponent = React.lazy(() => import('./OtherComponent'));`
React.lazy는 import()를 호출하는 함수를 인자로 r가진다. 이 함수는 프로미스를 반환한다
그렇게 생성된 레이지 컴포넌트는 아래와 같은 구문에서 사용된다
```javascript
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>

```
위의 suspense 컴포넌트는 레이지 로딩을 가능하게 해준다. 서버에 컴포넌트를 요청하는 동안은 fallback 어트리뷰트의 html 코드를 렌더링하고 컴포넌트 요청이 완료되면 해당 컴포넌트를 렌더링한다\
\
[링크](https://ko.reactjs.org/docs/context.html)

[링크](https://ko.reactjs.org/docs/code-splitting.html)

[공식홈페이지 문서](https://reactjs.org/docs/concurrent-mode-intro.html)

 hydrate과정이 블로킹을 유발하는 현상을 방지하는 것은 리액트의 오랜 숙제였다.

 약 1000여개가 넘는 html 엘리먼트를 논스톱으로 한번에 하이드레이트 하는 행위는 렌더러 스레드가 자바스크립트 실행 엔진에 의해 장시간 선점되는 결과를 초래한다. 이 상황은 페이지가 프리징되는 현상을 야기하여 사용자 경험을 저하시킨다.

 이런 문제는 하이드레이트 작업이 소규모 테스크 단위로 분리되지 않기 때문에 발생했다.

 그래서 사람들은 하이드레이션 작업을 다중 테스크로 분해하는 방법을 모색했다.

 이러한 하이드레이션 테크닉을 progressive hydration 또는 incremental hydration이라고 부른다.

 이러한 테크닉을 구현하는 방법은 여러가지가 있겠으나 리액트는 streaming SSR을 구현하면서 덤으로 이 문제를 (어느정도) 해결했다.

 streaming SSR은 대단히 단순한 컨셉으로부터 출발한다. html데이터를 한번에 전송하는 대신 컴포넌트 레벨로 분해하여 여러번에 걸쳐 순차적으로 전송하는 것이 핵심 아이디어인데 이렇게 할 경우 다방면에 걸쳐 유리하다.

 첫째로 서버측에서 클라이언트에게 데이터를 전송하는 딜레이, 다시말해 Time To First Byte(TTFB)를 줄일 수 있다. 이는 서버측에서 DB요청에 대한 응답을 기다리지 않고 가장 먼저 렌더링할 HTML 컴포넌트를 즉각적으로 클라이언트에게 전송하기 때문에 가능하다. DB요청이 완료되면 해당 DB와 관련된 HTML엘리먼트를 뒤이어 전송하면 되므로 아무런 문제가 없다.

 두번째로 클라이언트 측에서 렌더링을 수행하는 속도가 빨라진다. 이는 직관적으로 이해가 가능한 대목인데 부분적인 HTML엘리먼트를 렌더링하는 과정에서 렌더러 스레드가 렌더 트리를 생성하는데 걸리는 시간을 단축할 수 있기 때문이다.
 연산에 필요한 데이터가 그만큼 적으므로 이것은 당연하다.

 세번째는 incremental hydration으로 인한 이점인데, 전체 html파일이 아닌 html 컴포넌트 단위로 하이드레이션을 수행하기 자연스러운 환경이 조성된다. 만일 streaming SSR이 다층 레이어로 구성되어 단일 하이드레이션 테스크의 수행시간이 충분히 짦다면 하이드레이션 과정에서 웹페이지가 프리징되는 상황을 방지할 수 있다.

 여기까지가 streaming SSR 및 incremental hydration을 도입함으로서 얻을 수 있는 이익이었다. 이 주제에 관심이 있으면 댄 아브라모프가 작성한 https://lnkd.in/g23M7Hn 을 참조하는 것이 이해에 많은 도움을 줄 것이다.

그 외에 partial hydration이라는 개념도 눈여겨볼만 한데 이는 전체 html이 아닌 이벤트가 발생하는 html컴포넌트만을 하이드레이션 하는 기법이다.
 이를 적용하면 하이드레이션 타임이 줄어든다는 이점 외에도 가상DOM이 diff알고리즘을 수행하는 시간이 단축된다는 이점이 추가된다.

[출처](https://nextjs.org/docs/advanced-features/react-18)
상세는 [이 동영상](https://www.youtube.com/watch?v=TQQPAU21ZUw)을 참조하시오

### Q. 서버 컴포넌트 (Server Components)란 무엇인가 ?
먼저 헷갈릴 수 있는 개념인 서버 컴포넌트와 서버사이드 렌더링에 대해 짚고 넘어가자. 서버 컴포넌트 서버사이드 렌더링과는 다른 개념이다.\
\
먼저 이 둘의 공통점부터 짚고 넘어가자. 서버사이드 렌더링과 서버 컴포넌트 모두 렌더링을 서버에서 수행한다.\
\
반면 서버사이드 렌더링이 클라이언트 사이드에서 컴포넌트 하이드레이션을 수행하지만 서버 컴포넌트는 하이드레이션을 수행하지 않는다. 즉 클라이언트 사이드는 서버 컴포넌트와 관련하여 어떠한 자바스크립트 코드도 가지고 있지 않게된다\
\
어떻게 하이드레이션을 수행하지 않고도 웹페이지가 리액트 기반으로 구동될 수 있을까? 이것은 해당 컴포넌트가 완전히 정적인 컴포넌트라면 가능한 일이다. 컴포넌트가 정적이라면 유저 이벤트에 반응할 일이 없다. 시간이 변함에 따라 상태가 바뀔 일도 없다. 따라서 html로 렌더링한 결과를 뿌려준 후에는 재랜더링할 필요가 없으므로 리액트가 코드를 관리할 필요도 없어진다\
\
이렇게 완전 정적인 컴포넌트를 제외하고 오로지 동적인 컴포넌트만을 하이드레이션 하는 전략을 파셜 하이드레이션(partial hydration)이라고 한다\
\
즉 서버 컴포넌트는 파셜 하이드레이션 전략의 구현체이다\
\
파셜 하이드레이션은 두가지 측면에서 유리하다. 먼저 html이 로드된 후에 추가적으로 컴포넌트를 하이드레이션 하는 시간이 줄어든다. 하이드레이션 대상이 되는 컴포넌트의 수가 줄어들었으므로 이것은 당연한 이야기다.\
\
이렇게 하이드레이션 시간이 줄어듦으로서 렌더러 스레드가 자바스크립트 실행 엔진에 선점되는 시간이 줄어든다\
\
렌더러 스레드가 자바스크립트 실행 엔진에 선점되는 동안은 웹페이지가 유저와의 상호작용 및 페이지 렌더링 작업이 올스탑되므로 이는 유저 입장에서 마치 페이지가 프리징 된것처럼 느껴지며 따라서 UX를 저하시킨다\
\
그러므로 파셜 하이드레이션을 적용하면 웹페이지의 최초 구동시에 프리징 시간을 줄이는 효과가 있다\
\
또한 서버 컴포넌트와 관련된 js코드를 다운받지 않으므로 js의 파싱에 소모되는 시간이 없어진다. 이 또한 마찬가지로 웹페이지의 최초 구동시에 프리징 시간을 줄이는 효과가 있다

### Q. 공유 컴포넌트 (Shared Components)란 무엇인가 ?

서버와 클라이언트 양측에서 하나의 컴포넌트를 공유할 때 이 대상이 되는 컴포넌트를 공유 컴포넌트라고 한다\
\
생소할 수 있는 개념이지만 하나씩 살펴보자. 먼저 서버와 클라이언트가 컴포넌트를 공유한다는게 무슨뜻인가 ?
\
클라이언트 사이드에서 컴포넌트가 작동하는 개념은 익숙하다. 이와 마찬가지로 서버에도 클라이언트 사이드에서 사용하는 것과 동일한 컴포넌트를 동기화하여 코드를 작동할 수 있다. 즉 이런 개념은 `코드 실행의 위임`에 바탕을 둔다. 본래대로라면 클라이언트 측에서 실행되어야 할 컴포넌트의 로직을 서버에 위임하여 서버에서 컴포넌트의 로직을 실행한다는 개념이다\
\
예를 들어보자. 아래는 카운터 컴포넌트의 (적당한) 구현체이다
```javascript
function 카운터(){
    const [카운트, 카운트업] = useState()
    return (
        <>
            <p>현재 카운트는 {카운트}입니다</p>
            <button onClick={_ => 카운트업(++카운트)}>    카운트업    </button>
        </>
    )
}
```

위의 예에서 버튼을 클릭하면 `카운트설정` 함수가 호출되어 상태값이 변경되고 재랜더링 작업이 수행되어 페이지가 갱신된다. 이런 일반적인 페이지 갱신 과정을 서버에 위임해 보자. 먼저 onClick을 클릭했을 때 상태변경 함수를 호출하지 않고 그 대신 서버에 요청을 날린다. 이 요청은 크게 3가지 정보를 포함한다
1. 컴포넌트의 이름
1. 이벤트의 종류
1. 현재상태

서버가 이 요청을 받으면 주어진 정보를 토대로 상태를 변경하고 재랜더링 작업을 `서버에서` 수행한다. 이렇게 랜더링된 최종 html 코드를 다시 클라이언트에게 응답하면 클라이언트가 전달받은 html코드를 렌더링한다. 이것이 공유 컴포넌트가 작동하는 개괄적인 흐름이다. 이 흐름을 적당한 수도 코드로 작성하면 대략 아래와 같다

```javascript
function 카운터(){
    const [카운트, 카운트업] = useState()

    async function 서버요청(){
        const {html문자열} = await fetch('서버URL/api/서버컴포넌트', {
            컴포넌트이름 : '카운터',
            이벤트종류 : '카운트업',
            매개변수 : 카운트,
        }).then(res => res.json())

        ReactDOM.부분렌더링({
            타겟컴포넌트 : 카운터,
            렌더링값 : html문자열,
        })
    }

    return (
        <>
            <p>현재 카운트는 {카운트}입니다</p>
            <button onClick={서버요청}>카운트업</button>
        </>
    )
}
```
### 이 문서는 작성중입니다

---

## 기타

##### Q. 함수형 컴포넌트와 클래스 컴포넌트의 렌더링 메커니즘은 다른가 ?

댄(Dan Abramov)은 함수형 컴포넌트의 리랜더링 메커니즘이 클래스 컴포넌트의 그것과 동일하다고 답변했습니다.\
`they literally use the same code.`


### Q. 증분 렌더링(incremental rendering)이란 무엇인가?
증분 렌더링은 유저에게 높은 프레임 레이트 기반으로 부드럽게 변화하는 화면을 보여주기 위해 고안된 렌더링 기법이다\
\
무거운 렌더링 작업을 수행할 때 이 렌더링 작업을 도중에 중단없이 한번에 수행한다고 가정해보자\
\
이 때 리액트가 사용하는 자바스크립트 엔진은 렌더 스레드를 장시간 선점한다. 이 시간동안 렌더 스레드에서 수행될 수 있는 다른 모든 작업들은 일시중지된다.\
\
가령 유저의 입력을 받아서 처리하는 작업 또는 돔을 갱신하거나 렌더링을 요청하는 작업 등은 모두 일시중지 되는것이다.\
\
만일 자바스크립트를 실행하는 시간이 일정 시간을 초과하면 유저 입장에서는 마치 웹페이지가 프리징 된 것 같은 느낌을 준다.\
\
이는 유저 입장에서는 불쾌한 개념이며 사이트 이용의 만족도를 떨어뜨린다. 이처럼 뚝뚝 끊기는 화면으로 의한 불쾌한 사용자 경험을 감소시키려면 자바스크립트 코드가 렌더러 스레드를 선점하는 시간을 일정시간 이하로 낮추는 작업이 필요하다.\
\
리액트에서는 이것을 증분 렌더링이라는 개념으로 어느정도 극복했다. 증분 렌더링은 무거운 렌더링 작업을 수행할 때 수행되는 시간이 일정시간 초과된다면 수행한 지점까지의 정보는 환경변수에 기록한 뒤에 일단 렌더링을 수행하고 다음 렌더링 사이클이 오면 이전에 중단되었던 환경변수에 저장된 값을 기반으로 렌더링 프로세스를 재개하는 렌더링 메커니즘을 일컫는다


### Q. 함수형 컴포넌트에는 라이프사이클 개념이 없는가 ?

함수형 컴포넌트도 클래스 컴포넌트와 똑같은 라이프사이클을 사용한다\
\
클래스 컴포넌트에서는 이 라이프 사이클 이름을 기반으로 메소드 이름이 네이밍되었지만 함수형 컴포넌트에서는 직접적으로 라이프사이클 이름이 포함된 함수를 호출하지는 않는다.\
\
하지만 그게 함수형 컴포넌트에서는 라이프사이클 개념이 없다는 뜻은 아니다.\
\
라이프사이클에는 크게 아래의 6가지가 있다. 각 라이프사이클에 따라서 실행되는 함수가 다르다.\

```
componentWillMount : 컴포넌트가 마운트되기 직전에 발생한다
componentDidMount  : 컴포넌트가 마운트된 직후에 발생한다
componentWillUpdate :  컴포넌트가 업데이트되기 직전에 발생한다
componentDidUpdate :  :  컴포넌트가 업데이트된 직후에 발생한다
componentWillUnmount :  컴포넌트가 언마운트되기 직전에 발생한다
componentDidUnmount :  컴포넌트가 언마운트된 직후에 발생한다
```
### Q. 컴포넌트에 여러개의 옵션을 주어서 미세하게 다르게 렌더링하게 만들고 싶다. 이런경우 props가 10개가 넘어간다. 이걸 일일이 인자로 넘겨줘야 하는 상황은 너무 번거롭다. 더 간편하게 할 수 있는 방법이 있는가 ?

props에 디폴트 값을 주고 변경하고 싶은 인자만 넘겨주면 되는일이다. 이 디폴트 파라메터 기능은 ES6부터 적용되었다

---
## 디자인 패턴 관련

### Q. onclick등의 이벤트리스너를 함수를 작성할 때 인라인 화살표 함수로 표기하는 것이 옮은가 옮지 않은가 ?

인라인 화살표 함수를 좋게 보지않는 견해는 크게 두가지 이유가 있다.\
\
첫째로 인라인 함수는 함수의 이름이 명시되어 있지 않다. 따라서 함수의 이름을 보지 않으면 유추하기 어려운 코드인 경우는 인라인 화살표 함수의 사용을 지향하는 편이 좋겠다. 대소비교나 사칙연산 위주로 작성된 함수를 하나의 예시로 들 수 있겠다\
\
두번째 이유는 레이어가 분리되지 않기 때문이다. html 엘리먼트는 구조 레이어의 표현체이고 자바스크립트는 행위 레이어의 표현체이며 원래 이들 둘은 분리되어 작성되도록 설계되었다\
\
이렇게 이들 둘을 구분하여 작성하면 코드를 레이어 단위로 해석하는 것이 가능해지는데 이는 코드 가독성을 높임과 동시에 코드의 관리를 수월하게 한다\
\
인라인 함수를 작성한다면 이들 둘이 섞이므로 레이어가 분리되지 않게 된다. 이런 상황에서 함수를 수정한다고 가정해보자.\
\
먼저 함수를 찾아야 하는데 인라인 화살표 함수이므로 함수를 이름으로 찾을 수 없다.\
\
그러므로 함수를 찾는 것이 번거로워지는 문제가 생긴다\
\
두번째 문제는 함수를 찾는 영역이 넒어진다.\
\
만일 레이어간 분리가 뚜렷하여 모든 함수가 html이 표현된 곳이 아닌 자바스크립트 함수가 정의된 영역에 집중화 되어있다고 가정하자.\
\
예를 들어 그 코드가 총 1000줄이라면 함수를 1000줄 이내에서 찾으면 된다.\
\
하지만 html이 표현된 구조 레이어에도 함수가 선언되어 있다면 구조 레이어까지 감안해서 탐색해야 하는 수고로움이 발생한다.\
\
즉 탐색영역이 `1000줄 + @`로 증가한다. 이것은 유지보수를 더욱 까다롭게 만든다\
\
하지만 간단한 함수 호출 정도라면 큰 문제가 없는 것으로 본인은 판단한다

### Q. 고차 컴포넌트 (higher-order component) 패턴이란 ?

고차 컴포넌트는 기존의 컴포넌트에 추가적인 기능을 더해주는 기능이다\
\
컴포넌트를 인자로 받아서 컴포넌트에 새로운 기능을 추가한 후에 해당 컴포넌트를 리턴하는 패턴으로 사용한다\
\
오늘날까지 사용되는 고차 컴포넌트의 예로는 forwardRef 컴포넌트는. 이 컴포넌트는 인자로 받은 컴포넌트에게 두번째 파라메터를 더해준다. 그 두번째 파라메터로 외부에서 ref를 주입받아 컴포넌트 외부에 있는 html엘리먼트를 컨트롤할 수 있다\
\
하지만 이건 고차 컴포넌트를 사용하는 드문 경우이며 오늘날 고차 컴포넌트가 담당했던 대부분의 기능은 훅으로 대체할 수 있다.\
\
사실 고차 컴포넌트로 생성된 새로운 컴포넌트는 가독성이 떨어지는 편이다. 일단 컴포넌트 소스만 보고는 이 컴포넌트가 정확히 어떻게 작동할지 유추하기가 어렵기 때문이다.\
\
오늘날은 렌더 프롭스(render props)와 고차 컴포넌트로 구현했던 기능들을 훅으로 대체하는 것이 권장된다

### Q. 렌더 프롭스(render props)패턴이란 무엇인가 ?
클래스 컴포넌트에서 사용하는 패턴이다. 그저 `this.props.render()`라는 메소드를 호출하는 것이 전부이다.
일단 렌더 메소드를 호출하기 전에 선행과제가 있다. 컴포넌트를 호출할 때 `render`라는 어트리뷰트를 추가해야 한다. 아래와 같다
```javascript
<Component render={(name, age)=>{ return <Cat name={name} age={age}>}}>
```

이런 식으로 호출하는 것이 전제조건이다. 렌더는 콜백함수를 인자로 받으며 그 콜백함수는 리액트 컴포넌트를 리턴한다\
이제 이 Component 내부에서 `this.props.render('야옹이', 10)`이라고 호출을 한다. 그러면 위에서 정의해놓은 렌더의 콜백함수가 호출되고 Cat 컴포넌트를 리턴한다.\
\
결론을 요약하면 그저 다른 컴포넌트에게 변수나 함수를 프롭스로 넘겨주는 것이 전부다\
\
하지만 이런 패턴은 훅이 등장한 오늘날 사용할 당위성이 별로 없다. 훅으로 생성한 상태나 함수 등을 자식 컴포넌트에 넘겨주는 것으로 더 직관적으로 구현할 수 있게 되었기 때문이다

### 맵(map)을 사용해서 다수의 컴포넌트를 생성하는 패턴이 옮은가 옮지 않은가 ?
이건 생성하는 컴포넌트의 형질에 따라 다를 수 있다. 만일 복잡한 패턴의 컴포넌트를 여러개 생성한다면 맵은 훌륭한 솔루션이다. 하지만 여러개의 `단일 컴포넌트`를 생성한다고 가정해보자. 이 경우는 맵 함수를 쓰지 않고 하드 코딩으로 구현하는 편이 나을 수도 있다. 아래의 예를 들어보자

```javascript
<Sidebar title={'메인페이지'} url={'/main'} />
<Sidebar title={'장바구니'} url={'/cart'} />
<Sidebar title={'게시판'} url={'/bbs'} />
<Sidebar title={'마이페이지'} url={'/my'} />
<Sidebar title={'이용약관'} url={'/contract'} />
```
위의 코드는 페이지 구조를 직관적으로 보여준다는 관점에서 장점이 있다. 위의 코드를 맵으로 바꿔보자

```javascript
const 메뉴 =  [
    { title : '메인페이지', url : '/main'},
    { title : '장바구니', url : '/cart'},
    { title : '게시판', url : '/bbs'},
    { title : '마이페이지', url : '/my'},
    { title : '이용약관', url : '/contract'},
]

메뉴.map(v => <Sidebar title={v.title} url={v.url} />)
```

맵으로 구현된 코드는 데이터를 직관적으로 보여준다는 관점에서 장점이 있다.\
\
맵은 데이터 레이어와 구조 레이어(html)를 분리한다. 이러한 분리가 데이터를 관리한다는 관점에서는 좋은 선택이지만 어떤 사람들은 이런 표현이 구조적인 관점에서 코드를 해석하는 것을 저해한다고 느낀다.\
\
즉 이것은 기호의 문제라고 봐도 좋다. 결론적으로 데이터가 거의 불변이라서 앞으로 변할 일이 드물고 데이터의 양이 적으면서 단일 컴포넌트로 맵핑이 가능한 경우라면 본인의 취향에 맞추어 코딩해도 무방한 것으로 해석된다

---


### 리액트 컴포넌트 관련

### Q. 렌더리스 컴포넌트(renderless component)란 무엇인가?

렌더리스 컴포넌트는 말 그대로 어떤것도 화면상에 렌더링하지 않는 컴포넌트이다\
\
렌더리스 컴포넌트는 오직 이벤트 리스너의 목적으로 사용된다. 그리고 특히 전역 이벤트를 탐지하는 용도로 쓰인다\
\
유저가 스크롤하는 이벤트를 탐지하거나 웹브라우저가 리사이징되는 이벤트를 탐지하는 기능이 렌더리스 컴포넌트가 사용되는 대표적인 예이다


### Q. 프래그먼트 (Fragment) 컴포넌트가 무엇인가?

프래그먼트는 아무런 내용이 없는 빈 엘리먼트이다\
\
하나의 함수 컴포넌트는 하나의 루트 엘리먼트를 반환해야 한다. 그래서 div등을 루트 엘리먼트로 활용해서 다른 엘리먼트를 랩핑하는 패턴을 활용했는데 프래그먼트 컴포넌트를 사용하면 보다 깔끔하게 코드를 표현할 수 있다\
\
프래그먼트 컴포넌트는 html상에 표현되는 컴포넌트가 아니며 리액트에서 루트 엘리먼트를 표기하기 위한 용도로만 사용된다\
\
[공식링크](https://ko.reactjs.org/docs/fragments.html)


---


## css관련

###  css-in-js

css파일이 아닌 자바스크립트 파일 내부에서 css 규칙을 정의하는 코딩 스타일을 `css-in-js`라고 부른다.\
\
스타일드 컴포넌트같은 라이브러리가 대표적인 css-in-js의 예이다

### 테일윈드 css (tailwind css)

테일윈드를 이야기하기 앞서 부트스트랩 라이브러리를 이야기 해보자\
\
부트스트랩은 일일이 css 규칙을 정의하지 않아도 html 엘리먼트에 클래스 이름을 기입하는 것만으로 간편하게 사용할 수 있는 라이브러리이다. 이것이 가능한 이유는 부트스트랩 팀에서 미리 css 코드와 클래스 이름을 정의해놓았기 때문이다\
\
즉 부트스트랩을 사용하면 남이 만들어놓은 css를 그저 가져다 쓰면 될 뿐이므로 내가 css 규칙을 작성할 일이 거의 없다.\
\
부트스트랩에서 제공하는 클래스 이름만 암기하고 그 암기한 클래스 이름을 원하는 엘리먼트에 붙여넣으면 될 뿐이다\
\
그리고 이 부트스트랩의 후계자 정도 되는 라이브러리가 테일윈드 css라고 할 수 있다. 테일윈드 css도 부트스트랩과 마찬가지로 이미 정의되어 있는 css규칙을 사용한다. 유저는 그저 테일윈드에 정의되어 있는 클래스 이름을 암기하고 그 이름을 가져다가 특정 html 엘리먼트에 적용하기만 하면 되는 것이다.\
\
앞서 이야기했듯 내가 css규칙을 일일이 작성할 필요가 거의 없다는 점이 테일윈드 css의 가장 큰 장점이다. 극단적으로 말하면 프로젝트의 모든 스타일링을 테일윈드 만으로도 구현할 수 있다. 따라서 내가 작성해야 하는 css코드의 양을 제로로 줄일 수도 있다 \
\
하지만 단점으로는 클래스이름을 많이 적용하게 되면 코드가 너무 지저분해 지고 내가 어떤 속성을 적용했는지 한눈에 알아보기 어렵다는 단점이 있다. 이 단점은 극복이 거의 불가능하다. 이 치명적인 단점 때문에 테일윈드를 싫어하는 사람들이 많다\
\
그리고 암기해야 하는 클래스 이름이 많아 어느정도의 러닝커브가 있다. 테일윈드에 익숙해지기 전까지는 모니터 한켠에 테일윈드의 공식 docs 페이지를 띄어놓고 작업해야 한다

###  스타일드 컴포넌트(styled-components)란?

스타일드 컴포넌트는 css-in-js 패턴의 일종이다\
\
말 그대로 스타일이 적용된 컴포넌트를 생성한다\
\
함수 컴포넌트 내부에서 스타일 객체의 메소드를 호출하여 새로운 스타일이 적용된 컴포넌트를 반환한다\
\
아래 예는 스타일 객체에서 a메소드를 호출하여 새로운 스타일이 적용된 앵커 태그를 생성한다

```javascript
const AnchorTag = styled.a`
    color : red
` ;
```

이렇게 리턴된 컴포넌트는 일반적인 리액트 컴포넌트처럼 사용할 수 있다\
\
스타일드 컴포넌트가 주목받는 이유는 두가지 정도가 있다\
\
첫째로 함수 컴포넌트의 리턴부분이 깔끔해진다. html엘리먼트에 어떠한 클래스네임도 기입할 필요가 없기 때문이다\
\
두번째로 함수 컴포넌트의 완전한 고립화가 가능해진다. 외부의 css파일에서 css속성을 임포트하지 않아도 되므로 단일 파일 형태로 관리하기 쉽다. 이에 따라 자연스럽게 재사용성도 높아진다\
\
세번째로 레가시 코드를 새로운 css 프레임워크로 대체할 때 코드를 리팩토링할 필요가 없다. 앞서 말했듯 스타일드 컴포넌트가 적용된 리액트 컴포넌트는 완전한 고립화가 가능하므로 다른 컴포넌트에서 테일윈드 css등의 별개의 프레임워크를 사용한다 하더라도 충돌을 일으키지 않은 채 정상적으로 작동한다\
\
하지만 스타일드 컴포넌트는 css 정의와 리액트 컴포넌트 정의부분이 분리되지 않으므로 다른 컴포넌트에서 css 정의를 재사용하기 어렵다는 단점이 있다

### 함수 컴포넌트 내부에서 사용하는 `<style jsx>{" "}` 같은 패턴을 뭐라고 부르는가 ?

이것은 `스타일드 jsx(styled-jsx)` 라고 부른다. 버셀(vercel)에서 개발한 스타일드 jsx 라이브러리는 함수 컴포넌트 내부에서 사용하는 `css-in-js` 패턴의 일종이다.\
\
스타일드 jsx에서 선언된 css 규칙은 해당 컴포넌트에만 국소적으로 적용된다.\
\
이는 스타일드 컴포넌트 라이브러와 유사하지만 둘 사이의 차이점이 있다.\
\
스타일드 jsx는 css규칙을 선언한 후에 html엘리먼트에도 클래스이름을 기입해야 하는 번거로움이 있다.\
\
하지만 스타일드 컴포넌트로 정의된 리액트 컴포넌트에는 별도의 클래스네임을 기입할 필요가 없다는 편의성이 있다.\
\
이런 면에서 보면 스타일드 jsx의 진화된 버전이 스타일드 컴포넌트라고 해석할 수도 있지만 꼭 스타일드 컴포넌트가 더 좋다고 볼 수는 없다\
\
왜냐하면 스타일드 컴포넌트는 코드부와 css정의부가 독립되기 않기 때문이다.\
\
코드부와 css정의부가 독립되는게 왜 중요한가?\
\
이들 둘이 분리되어 있는 경우에는 관심사의 분리가 이루어진 것이며 관심사가 분리된 경우에는 코드의 유지보수가 더 수월해진다\
\
css 디피니티브 가이드(css definitive guide)의 공저자인 에스텔 웨일(Estelle Weyl)은 css와 js코드가 분리되어야 한다고 주장했는데 그렇게 해야하는 이유는 레이어를 분리하기 위함이다.\
\
애초에 웹을 구성하는 도구가 html, css, javascript의 3가지로 나뉜것도 레이어를 분리해서 유지보수를 수월하게 하기 위함이었다고 그녀는 말한다.\
\
구체적으로 이야기하면 css는 표현 계층(presentational layer)의 구현체이며 자바스크립트는 행동 계층(Behavioral layer)의 구현체이다.\
\
이들 둘이 분리된건 우연이 아니며 의도적인 것이었다.\
\
그런데 오늘날 `css-in-js`를 통하여 표현 계층과 행동 계층을 합병하려 하고 있으니 이것은 썩 바라짐하지 못하다고 그녀는 이야기하고 있는 것이었다.\
\
그러므로 우리는 외부에서 css를 항상 임포트해서 써야 하는가? 리액트의 관점에서 보면 그것도 썩 바람직하다고는 볼 수 없는 것이다.\
\
왜냐하면 그것은 단일 파일이 하나의 컴포넌트로 완결성을 지니는 고립성(isolation)을 해치기 때문이다.\
\
그런 관점에서 볼 때 스타일드 jsx는 레이어의 분리와 컴포넌트의 고립성을 보장하면서 어느정도는 레이어를 분리시키는 이 두가지 원칙의 절충점이라고 볼 수 있다\
\
비록 스타일드 jsx가 js파일 내부에서 사용된다고는 할지라도 단일 jsx구문은 코드에 산발적으로 흩어져있지 않으며 한곳에 응집되어 있다\
\
따라서 이리저리 css코드를 찾으러 헤메일 필요가 없는 것이다.\
\
이런면에서 볼 때 어느정도는 레이어의 분리가 성립되었다고도 평가할 수 있는 것이다\
\
결론을 말하면 완전한 레이어의 분리를 유지하여 개발하고 싶다면 css 모듈이 적합하고 리액트 컴포넌트를 단일 파일로 고립시킨 상태에서 어느정도의 레이어의 분리를 원한다면 스타일드 jsx가 적합하다


### css module

css 모듈은 특정 컴포넌트에만 국소적으로 스타일을 적용하는 css 테크닉이다\
\
css 모듈은 일반적인 css 임포트 (import) 패턴과 거의 같은 패턴이므로 새롭게 배울 내용은 거의 없다\
\
다만 css 파일명은 `컴포넌트명.module.css`과 같은 포멧으로 작성한다\
\
그리고 css를 적용할 때는 임포트된 css 모듈에 프로퍼티로 정의된 클래스 이름을 사용한다\
\
클래스명이나 아이디 어트리뷰트를 css 식별자로 사용할 수 있지만 아이디 사용은 권장하지 않는다. 아이디는 유니크한 값이므로 적용할 수 있는 엘리먼트가 매우 제한적이기 때문이다\
\
같은 css모듈을 사용하더라도 임포트 할 때마다 고유한 클래스 이름이 생성되어 다른 컴포넌트에서 같은 css 모듈을 사용한다고 해도 클래스명이 겹칠 일은 없다\
\
이것이 특정 컴포넌트에만 국소적으로 스타일을 적용하게 해주는 핵심 원리다\

### Q. `css 모듈`에 안티 패턴이 있는가?
A. 부모 컴포넌트에서 생성된 클래스네임을 자식 컴포넌트로 상속하지 않는 편이 좋다.\
\
CSS 모듈을 임포트하고 나서 해당 모듈에서 제공하는 클래스네임을 자식 컴포넌트에 프롭스로  전달하지 않는 편이 좋다.\
\
만일 css 모듈 파일에서 클래스 이름을 변경했을 때 단일 컴포넌트에서만 사용하는 경우 클래스 네임의 변경은 쉽다. 그저 IDE를 켜고 일괄적으로 이름바꾸기 기능을 사용하면 10초 내외로 끝나는 작업이다.\
\
하지만 불특정 다수의 자식 컴포넌트에서 해당 클래스 이름을 가져다가 사용하는 경우는 자식 컴포넌트가 정의된 모든 파일을 순회하며 클래스 이름을 변경해줘야 하는 번거로움이 발생한다

### SASS(Syntactically Awesome Stylesheets) 란 ?

사스는 css의 변종 언어이며 이 언어는 빌드 과정에서 css로 트랜스파일 된다\
\
사스는 css 표준 문법보다 더욱 프로그래밍 언어스럽게 개발할 수 있다는 장점이 있다. 즉 사스는 변수, 믹스인, 중첩과 같은 기능을 제공한다. 이러한 기능들은 개발의 편의성을 제공한다\
\
요즘은 css 표준에도 변수같은 기능이 추가되어 사스를 사용할 이유가 점차 줄어들고 있기는 하다


---

## 테스트 관련

### Q. 테스트 주도 개발이란 무엇인가?
먼저 테스트의 개념을 이해해야 한다. 테스트란 임의의 시나리오를 가정하여 테스트 코드를 작성하고 그 테스트 코드의 최종 결과가 원하는 결과가 매칭되는지를 확인하는 과정을 말한다.
그리고 테스트 주도 개발이란 프로덕션에 적용할 함수별로 이런 테스트를 수행하여 오직 함수의 정상적인 작동이 보장되는 상황에서만 해당 함수를 프로덕션 코드에 적용하는 코딩 프랙티스를 의미한다
이런 TDD는 에러를 발생하지 않는 코드만을 실제 프로덕션에 투입하여 얘기치 않은 작동을 뿌리부터 제거한다는 의의가 있다
하지만 모든 함수를 TDD기반으로 작성하는 것은 번거롭다는 단점이 있다. 덧붙여서 TDD는 유지보수 도중 함수를 수정했을 때 문제를 야기한다. 함수 시그니쳐를 변경하는 리팩토링을 수행할 때 마다 테스트를 다시 작성해야 하는 번거로움이 있다

### 어떤식으로 테스트를 구현하는가?
대부분의 테스트 라이브러리는 테스트 함수를 호출하는 형태로 테스트를 수행한다. 아래와 같은 식이다

```javascript
const 덧셈함수 = (a,b) => a + b

test("테스트의 이름", function 테스트함수(){

    const 덧셈결과 = 덧셈함수 (1,1)
    expect(덧셈결과).toBe(2)
})
```
위의 코드는 `덧셈함수`의 간단한 테스트 코드이다. 덧셈함수는 `테스트함수`내부에서 호출되어 그 리턴값이 예상한 리턴값인지 체크하는 `expect`함수를 호출함으로서 마무리된다. 만일 예상한 값과 실제 값이 같다면 콘솔창에 그린 라이트가 표시되면서 테스트는 통과된다. 만일 예상한 값과 실제 값이 다르다면 콘솔창에 레드 라이트가 표시되면서 테스트의 실패를 알려준다.

### Q. 리액트에서도 TDD가 가능한가?
A. 결론부터 말하면 리액트에서도 TDD가 어느 정도는 가능하다. 하지만 리액트는 웹 프론트환경에서 작동하는 프로그램이다.\
\
웹 프론트엔드는 다른 환경에 비하면 테스트 코드의 구현 난이도가 높고 가능한 테스트 커버리지도 상대적으로 제한적이다.\
\
jest로 대표되는 테스트 코드 작성은 정해진 입력에 대하여 정해진 출력을 테스트하는 순수 함수적인 전략을 취하지만 웹 프론트엔드 환경은 순수함수적인 작동을 방해하는 부수효과가 많다. 유저입력과 서버와의 통신은 대표적인 부수 효과에 속한다\
\
만일 웹브라우저의 구동환경 및 유저 입력이라는 부수효과까지 고려하여 테스트하고 싶다면 헤드리스 브라우저 기반의 테스트 코드를 작성해야 한다. 하지만 헤드리스 기반의 테스트 코드 작성은 생각보다 쉽지 않다\
\
누군가는 이런 웹 프론트엔드 환경을 가리켜 `개발자가 상상할 수 있는 가장 터프한 프로그램 구동환경`이라는 말까지 했다.\
\
한편 리액트의 TDD에는 제스트, 모카, 엔자임 등이 사용된다. 퍼핏티어는 이들과 결합하여 사용할 수 있다\

### Q. 퍼핏티어 기반의 TDD는 어떻게 수행되는가 ?
실제 웹브라우저를 구동하여 타겟 페이지로 이동 후 유저의 입력을 모방하는 방식으로 테스트가 수행된다. 즉 퍼핏티어는 가장 실제적인 상황을 시뮬레이션 하여 테스트를 수행한다\
\
UI에서 특정한 원소를 선택하여 마우스를 클릭한거나 키보드를 입력하는 액션을 수행하고 일정 시간이 지난 후 UI가 원하는 방식으로 변화되었는지를 탐지하는 방식으로 테스트가 수행된다
