# 리코일 Q&A

Q. 리코일이 뭔가?\
A. 리코일은 상태관리 라이브러리다\
\
Q. 리코일 사용법을 간단하게 소개해줄 수 있는가?\
A. 리액트에는 useState라는 훅이 있다. 이 훅은 상태를 저장하고 변경할 수 있다\
리코일에도 useState와 비슷한 훅이 있다. 그것이 useRecoilState이다\
\
Q. useRecoilState는 useState쓰듯이 사용하면 되는가?\
A. 거의 비슷한데 함수가 인자로 받는 값이 다르다. useState는 인자로 데이터 넘겨줄 때 아무런 가공없이 쌩으로 넘겨줬다. 하지만 리코일의 useRecoilState는 아톰이라는 형태로 데이터를 랩핑해서 넘겨준다. 가령 아래와 같다
```dotnetcli
atom({
    key: '이_값은_유일해야_한다',
    default: '여기에_기본값을_입력',
});
```
위의 아톰을 보면 알겠지만 데이터에 키를 부여하는 것 뿐이다. 데이터를 가져올 때 어떤 데이터를 가져오는지 이름 정도는 알아야 할 것 아닌가? 키(key)는 데이터의 이름에 해당한다\
\
Q. 데이터를 어디에서 가져오는가?\
A. 데이터는 전역 스토어에서 가져온다. 이 전역 스토어는 리액트의 어떠한 컴포넌트에서도 참조할 수 있다. 따라서 데이터를 자식 컴포넌트로 계속 넘겨주는 프롭스 드릴링(props drilling)이 필요가 없다.\
\
Q. 어느 컴포넌트에서든지 상태를 전역스토어에서 가져올 수 있다고 했는데, 그 상태가 다른 컴포넌트에서  변경되면 그 변경사항을 어떻게 탐지하는가? 상태의 변경이 감지되면 컴포넌트가 재호출되어야 하는데 그런데 어떻게 그것이 가능한가?\
A. 그건 컴포넌트가 상태를 구독하면 가능하다. 다른 컴포넌트가 값을 갱신할 때 이 갱신된 내용을 구독자 컴포넌트가 탐지한다. 컴포넌트가 변경사항을 탐지했으면 해당 컴포넌트 함수는 다시 호출된다. 그 구독은 셀렉터 함수를 통해서 이루어진다. 구체적으로 말하면 useRecoilValue라는 훅에 셀렉터 함수의 리턴값을 인자로 넣어주면 컴포넌트가 해당 셀렉터의 키(key)를 구독하게 된다.\
\
Q. 정리하면 상태를 생성할 때는 아톰 함수로 생성하고 상태를 구독할 때는 셀렉터 함수로 구독하는 것인가?\
A. 그렇다. 아톰과 셀렉터는 사용법이 거의 유사하다. 이들은 훅의 인자로 들어간다. 다시 말하면 아톰은 useRecoilState함수의 인자로 들어가고 셀렉터는 useRecoilValue의 인자로 들어간다. 이들 두 함수는 이름이 비슷하여 헷갈리기 쉽다. 조금 이해를 돕자면 useRecoilState는 중간의 Recoil이라는 글자만 제외하면 useState이다. useState 훅은 본래 상태를 생성하고 상태를 변경하는 함수다. useRecoilState도 마찬가지로 상태를 생성하고 상태를 변경한다. 즉 상태생성기라고 이해해도 좋다.\
반면 useRecoilValue는 중간의 Recoil이라는 단어만 제외하면 useValue이다. 이건 리액트의 기본 훅 중에서 대응할만한 훅이 없다. 그냥 값을 가져다 쓴다고 이해하자. 명백한건 useRecoilValue는 상태를 생성하는 역할은 아니며 그저 구독하는 역할이라는 점이다.\
\
Q. 다른 컴포넌트에서 생성한 상태를 가져오되, 상태까지 변경하고 싶으면 어떻게 하는가 ?\
A. 상태를 가져오는건 useRecoilValue로 가져오고, 상태를 변경하고 싶으면 useSetRecoilState로 세터(setter)를 가져온다.\
사실 함수 이름이 너무 장황한데 단순하게 분류하면 useRecoilState는 `상태생성`, useRecoilValue는 `구독하기`이고 useSetRecoilState는 `상태변경하기`이다.\
\
Q. 리코일은 useState의 대안인가?\
A. 일부 그렇지만 완전한 대안은 아니다. `useState로 간단하게 끝날 수 있는 프로젝트`는 useState를 쓰는 것이 이상적이다\
useState를 권장하는 큰 이유는 다른 컴포넌트와 상태를 공유하지 않아도 되기 때문이다. 만일 상태를 자식 컴포넌트에게 건내주지 않는다면 하나의 컴포넌트가 상태를 독점해서 사용할 수 있다. 오해를 막기위해 첨언하면 이런 상황에서도 useState의 상태가 특정 컴포넌트에 귀속된 것은 아니다. useState의 상태는 리액트라는 컨텍스트에서 전역으로 관리된다. 그러니 하나의 컴포넌트에서 useState를 독점적으로 쓰고있는 상황을 `로컬 상태를 쓰고 있다고 말하기는 어렵다`.\
하지만 리액트 컨텍스트는 개발자가 아무렇게나 접근할 수 있는 영역이 아니다. 따라서 다른 컴포넌트에서 함부로 상태 참조가 불가능하므로 상태공유를 금기시하는 함수형의 관점에서 보면 `어느 정도`는 타당한 사용법이라고 볼 수 있다.\
\
Q. 다른 컴포넌트와 상태를 공유하지 않는 것이 왜 장점인가?\
A. 함수가 예측가능한 형태로 실행되기 때문이다. 1번부터 100번까지의 컴포넌트가 하나의 상태를 공유하고 있다고 해보자. 그런 상황에서 1번 컴포넌트가 어떻게 렌더링될지 예측하는 것은 어렵다. 2번부터 100번까지의 다른 컴포넌트가 setState를 하는 순간 1번 컴포넌트는 다시 렌더링된다. 다시 말해 2번부터 100번까지의 다른 컴포넌트에 의해 1번 컴포넌트의 렌더링 방식이 결정된다. 만일 1번 컴포넌트의 상태가 예상치 못한 방식으로 렌더링이 되었다고 해보자. 즉 버그가 난것인데 이 버그의 원인을 어디서 찾을 것인가? 1번부터 100번 까지의 컴포넌트가 에러의 원인 후보에 오를 수 있다. 이런 상황에서 에러의 원인을 찾는 것은 고역이다. 사실 에러는 그 범위를 최대한 좁혀두고 찾는 것이 이상적이므로 디버깅의 관점에서 보면 컴포넌트간 상태를 공유하는 것은 지양해야 할 관례라고 할 수 있다
\
Q. useState를 권장하는 다른 이유가 있는가?
A. useState를 권장하는 이유는 단순한 사용법도 한 몫 한다. useState는 모든 상태관리 기법을 통틀어 사용법이 가장 단순하다. 단순한 방법으로 해결되는 상황이라면 굳이 복잡한 방법을 택할 이유는 없다. 만일 여러개의 컴포넌트간 상태를 공유하지 않는 상황이라면 useState만으로도 상태관리를 쉽게 할 수 있다. useState를 썻을 때 상태관리가 복잡해지는 상황은 여러 컴포넌트에서 하나의 상태를 공유할 때인데 이럴 때는 다른 상태관리 방법을 찾게 된다\
\
Q. 그러면 하나의 상태를 여러 컴포넌트가 공유한 상황에서 리코일은 어떻게 복잡성을 줄였나?\
A. 위에서 말했듯 두가지 컨셉으로 복잡성을 줄였다
1. 전역 스토어
1. 구독자-발행자 모델

전역 스토어는 거대한 전역 변수로 이해해도 좋다. 전역 스토어는 어떤 컴포넌트에서도 간단하게 상태를 참조할 수 있게 해준다. 전역 스토어에 접근할 때는 훅을 사용한다. 훅을 호출해서 전역 스토어의 값을 리턴받는 형식이다. 이런 방식은 일종의 자유변수를 참조하는 방식으로 해석할 수도 있다. 자유 변수는 함수 밖에서 선언된 변수를 뜻한다. 자유 변수는 함수의 일관된 작동을 저해하므로 권장되는 코딩 방법은 아니다. 하지만 복잡한 상태관리를 덜 복잡하게 구현하려면 자유변수 외에는 마땅한 솔루션이 없다\
자유 변수가 함수의 일관된 작동을 저해한다는 말이 이해가 가지 않는다면 `Q. 다른 컴포넌트와 상태를 공유하지 않는 것이 왜 장점인가?` 항목을 참조할것\

# 이 문서는 작성중입니다