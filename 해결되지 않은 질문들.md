# 해결되지 않은 질문들 모음

---
##  일반 질문

### 렌더리스 컴포넌트(renderless component)란 무엇인가?

렌더리스 컴포넌트는 말 그대로 어떤것도 화면상에 렌더링하지 않는 컴포넌트이다\
\
렌더리스 컴포넌트는 오직 이벤트 리스너의 목적으로 사용된다. 그리고 특히 전역 이벤트를 탐지하는 용도로 쓰인다\
\
유저가 스크롤하는 이벤트를 탐지하거나 웹브라우저가 리사이징되는 이벤트를 탐지하는 기능이 렌더리스 컴포넌트가 사용되는 대표적인 예이다

### Q. 함수로서의 자식 (children as function) 패턴이란 무엇인가 ?
A. 답을 찾는 중

### Q. 컴포넌트에 여러개의 옵션을 주어서 미세하게 다르게 렌더링하게 만들고 싶다. 이런경우 props가 10개가 넘어간다. 이걸 일일이 인자로 넘겨줘야 하는 상황은 너무 번거롭다. 더 간편하게 할 수 있는 방법이 있는가 ?

props에 디폴트 값을 주고 변경하고 싶은 인자만 넘겨주면 되는일이다. 이 디폴트 파라메터 기능은 ES6부터 적용되었다

### Q. 함수형 컴포넌트에는 라이프사이클 개념이 없는가 ?

함수형 컴포넌트도 클래스 컴포넌트와 똑같은 라이프사이클을 사용한다\
\
클래스 컴포넌트에서는 이 라이프 사이클 이름을 기반으로 메소드 이름이 네이밍되었지만 함수형 컴포넌트에서는 직접적으로 라이프사이클 이름이 포함된 함수를 호출하지는 않는다.\
\
하지만 그게 함수형 컴포넌트에서는 라이프사이클 개념이 없다는 뜻은 아니다.\
\
라이프사이클에는 크게 아래의 6가지가 있다. 각 라이프사이클에 따라서 실행되는 함수가 다르다.\

```
componentWillMount : 컴포넌트가 마운트되기 직전에 발생한다
componentDidMount  : 컴포넌트가 마운트된 직후에 발생한다
componentWillUpdate :  컴포넌트가 업데이트되기 직전에 발생한다
componentDidUpdate :  :  컴포넌트가 업데이트된 직후에 발생한다
componentWillUnmount :  컴포넌트가 언마운트되기 직전에 발생한다
componentDidUnmount :  컴포넌트가 언마운트된 직후에 발생한다
```

### Q. 리액트에서도 TDD가 가능한가?
A. 결론부터 말하면 리액트에서도 TDD가 어느 정도는 가능하다. 하지만 리액트는 웹 프론트환경에서 작동하는 프로그램이다.\
\
웹 프론트엔드는 다른 환경에 비하면 테스트 코드의 구현 난이도가 높고 가능한 테스트 커버리지도 상대적으로 제한적이다.\
\
jest로 대표되는 테스트 코드 작성은 정해진 입력에 대하여 정해진 출력을 테스트하는 순수 함수적인 전략을 취하지만 웹 프론트엔드 환경은 순수함수적인 작동을 방해하는 부수효과가 많다. 유저입력과 서버와의 통신은 대표적인 부수 효과에 속한다\
\
만일 웹브라우저의 구동환경 및 유저 입력이라는 부수효과까지 고려하여 테스트하고 싶다면 헤드리스 브라우저 기반의 테스트 코드를 작성해야 한다. 하지만 헤드리스 기반의 테스트 코드 작성은 생각보다 쉽지 않다\
\
누군가는 이런 웹 프론트엔드 환경을 가리켜 `개발자가 상상할 수 있는 가장 터프한 프로그램 구동환경`이라는 말까지 했다.\
\
한편 리액트의 TDD에는 제스트, 모카, 엔자임, 퍼핏티어 등이 사용된다\

---

## 디자인 패턴 관련
### Q. 왜 리액트는 MVC가 아닌가?

리액트 코어팀은 양방향 데이터 플로우를 싫어했다.\
\
앵귤러 등의 양방향 데이터 플로우를 지원하는 MVC계열 프레임워크는 데이터의 이동을 추적하기 어려웠다. 그래서 디버깅이 어려웠고 많은 사람들이 떠났다.\
\
리액트 팀은 데이터를 쉽게 추적할 수 있고 그 결과 디버깅도 쉬워지는 단방향 데이터 흐름을 선호했다.\
\
이러한 패러다임을 기반으로 탄생한 플럭스 아키텍처는 기존의 MVC모델과는 다른 접근방식을 지향했다\
\
즉 리액트는 뷰와 모델간의 양방향 데이터 흐름을 지원하지 않기 때문에 MVC라고 보기 어렵다

### 리액트에서 믹스인(mixin) 패턴이란 무엇인가?

믹스인은 서로 다른 두개의 컴포넌트가 일부 코드를 공유하는 코딩 패턴을 말한다.\
\
이는 클래스 컴포넌트의 상속 기능을 통해 구현된다.\
\
부모 컴포넌트가 있고 자식 컴포넌트가 부모 컴포넌트를 상속받아서 구현되었다고 가정해 보자.\
\
부모가 자식을 상속했으므로 부모와 자식 컴포넌트는 일부 코드를 공유한다.\
\
이같은 상황에서 부모 컴포넌트를 수정하기는 매우 조심스러운 일이다. 부모 컴포넌트를 수정하려면 자식 컴포넌트의 동작까지 고려해야 한다\
\
결론적으로 리액트에서 믹스인은 유해한 것으로 간주된다. 왜냐하면 믹스인을 적용할 경우 단일 컴포넌트는 단독적으로 수정할 수도 없으며 여러 수많은 컴포넌트를 고려하여 설계되어야 하기 떄문이다\
\
상세는 [링크](https://ko.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)를 참조하시오

### Q. onclick등의 이벤트리스너를 함수를 작성할 때 인라인 화살표 함수로 표기하는 것이 옮은가 옮지 않은가 ?

인라인 화살표 함수를 좋게 보지않는 견해는 크게 두가지 이유가 있다.\
\
첫째로 인라인 함수는 함수의 이름이 명시되어 있지 않다. 따라서 함수의 이름을 보지 않으면 유추하기 어려운 코드인 경우는 인라인 화살표 함수의 사용을 지향하는 편이 좋겠다. 대소비교나 사칙연산 위주로 작성된 함수를 하나의 예시로 들 수 있겠다\
\
두번째 이유는 레이어가 분리되지 않기 때문이다. html 엘리먼트는 구조 레이어의 표현체이고 자바스크립트는 행위 레이어의 표현체이며 원래 이들 둘은 분리되어 작성되도록 설계되었다\
\
이렇게 이들 둘을 구분하여 작성하면 코드를 레이어 단위로 해석하는 것이 가능해지는데 이는 코드 가독성을 높임과 동시에 코드의 관리를 수월하게 한다\
\
인라인 함수를 작성한다면 이들 둘이 섞이므로 레이어가 분리되지 않게 된다. 이런 상황에서 함수를 수정한다고 가정해보자.\
\
먼저 함수를 찾아야 하는데 인라인 화살표 함수이므로 함수를 이름으로 찾을 수 없다.\
\
그러므로 함수를 찾는 것이 번거로워지는 문제가 생긴다\
\
두번째 문제는 함수를 찾는 영역이 넒어진다.\
\
만일 레이어간 분리가 뚜렷하여 모든 함수가 html이 표현된 곳이 아닌 자바스크립트 함수가 정의된 영역에 집중화 되어있다고 가정하자.\
\
예를 들어 그 코드가 총 1000줄이라면 함수를 1000줄 이내에서 찾으면 된다.\
\
하지만 html이 표현된 구조 레이어에도 함수가 선언되어 있다면 구조 레이어까지 감안해서 탐색해야 하는 수고로움이 발생한다.\
\
즉 탐색영역이 `1000줄 + @`로 증가한다. 이것은 유지보수를 더욱 까다롭게 만든다\
\
하지만 간단한 함수 호출 정도라면 큰 문제가 없는 것으로 본인은 판단한다

### Q. 고차 컴포넌트 (higher-order component) 패턴이란 ?

고차 컴포넌트는 기존의 컴포넌트에 추가적인 기능을 더해주는 기능이다\
\
컴포넌트를 인자로 받아서 컴포넌트에 새로운 기능을 추가한 후에 해당 컴포넌트를 리턴하는 패턴으로 사용한다\
\
오늘날까지 사용되는 고차 컴포넌트의 예로는 forwardRef 컴포넌트는. 이 컴포넌트는 인자로 받은 컴포넌트에게 두번째 파라메터를 더해준다. 그 두번째 파라메터로 외부에서 ref를 주입받아 컴포넌트 외부에 있는 html엘리먼트를 컨트롤할 수 있다\
\
하지만 이건 고차 컴포넌트를 사용하는 드문 경우이며 오늘날 고차 컴포넌트가 담당했던 대부분의 기능은 훅으로 대체할 수 있다.\
\
사실 고차 컴포넌트로 생성된 새로운 컴포넌트는 가독성이 떨어지는 편이다. 일단 컴포넌트 소스만 보고는 이 컴포넌트가 정확히 어떻게 작동할지 유추하기가 어렵기 때문이다.\
\
오늘날은 렌더 프롭스(render props)와 고차 컴포넌트로 구현했던 기능들을 훅으로 대체하는 것이 권장된다

### Q. 렌더 프롭스(render props)패턴이란 무엇인가 ?
클래스 컴포넌트에서 사용하는 패턴이다. 그저 `this.props.render()`라는 메소드를 호출하는 것이 전부이다.
일단 렌더 메소드를 호출하기 전에 선행과제가 있다. 컴포넌트를 호출할 때 `render`라는 어트리뷰트를 추가해야 한다. 아래와 같다
```javascript
<Component render={(name, age)=>{ return <Cat name={name} age={age}>}}>
```

이런 식으로 호출하는 것이 전제조건이다. 렌더는 콜백함수를 인자로 받으며 그 콜백함수는 리액트 컴포넌트를 리턴한다\
이제 이 Component 내부에서 `this.props.render('야옹이', 10)`이라고 호출을 한다. 그러면 위에서 정의해놓은 렌더의 콜백함수가 호출되고 Cat 컴포넌트를 리턴한다.\
\
결론을 요약하면 그저 다른 컴포넌트에게 변수나 함수를 프롭스로 넘겨주는 것이 전부다\
\
하지만 이런 패턴은 훅이 등장한 오늘날 사용할 당위성이 별로 없다. 훅으로 생성한 상태나 함수 등을 자식 컴포넌트에 넘겨주는 것으로 더 직관적으로 구현할 수 있게 되었기 때문이다

### 맵(map)을 사용해서 다수의 컴포넌트를 생성하는 패턴이 옮은가 옮지 않은가 ?
이건 생성하는 컴포넌트의 형질에 따라 다를 수 있다. 만일 복잡한 패턴의 컴포넌트를 여러개 생성한다면 맵은 훌륭한 솔루션이다. 하지만 여러개의 `단일 컴포넌트`를 생성한다고 가정해보자. 이 경우는 맵 함수를 쓰지 않고 하드 코딩으로 구현하는 편이 나을 수도 있다. 아래의 예를 들어보자

```javascript
<Sidebar title={'메인페이지'} url={'/main'} />
<Sidebar title={'장바구니'} url={'/cart'} />
<Sidebar title={'게시판'} url={'/bbs'} />
<Sidebar title={'마이페이지'} url={'/my'} />
<Sidebar title={'이용약관'} url={'/contract'} />
```
위의 코드는 페이지 구조를 직관적으로 보여준다는 관점에서 장점이 있다. 위의 코드를 맵으로 바꿔보자

```javascript
const 메뉴 =  [
    { title : '메인페이지', url : '/main'},
    { title : '장바구니', url : '/cart'},
    { title : '게시판', url : '/bbs'},
    { title : '마이페이지', url : '/my'},
    { title : '이용약관', url : '/contract'},
]

메뉴.map(v => <Sidebar title={v.title} url={v.url} />)
```

맵으로 구현된 코드는 데이터를 직관적으로 보여준다는 관점에서 장점이 있다.\
\
맵은 데이터 레이어와 구조 레이어(html)를 분리한다. 이러한 분리가 데이터를 관리한다는 관점에서는 좋은 선택이지만 어떤 사람들은 이런 표현이 구조적인 관점에서 코드를 해석하는 것을 저해한다고 느낀다.\
\
즉 이것은 기호의 문제라고 봐도 좋다. 결론적으로 데이터가 거의 불변이라서 앞으로 변할 일이 드물고 데이터의 양이 적으면서 단일 컴포넌트로 맵핑이 가능한 경우라면 본인의 취향에 맞추어 코딩해도 무방한 것으로 해석된다

##### 프롭스(props)를 디컨스트럭팅 하여 자식 컴포넌트에게 인자로 넘겨주는 패턴이 옮은가 옮지 않은가 ?
---

### 리액트 컴포넌트

### Q. 프로파일러 (profiler) 컴포넌트가 무엇인가 ?

프로파일러 컴포넌트는 일종의 랩퍼 컴포넌트인데 이는 자식 컴포넌트의 렌더링 코스트를 계산한다\
\
프로파일러 컴포넌트는 `<Profiler></Profiler>`와 같이 기입해서 사용한다. 구체적인 예시는 아래와 같다

```javascript
  <Profiler id="nav" onRender={callback}>
    <Navigation {...props} />
  </Profiler>

```

### Q. 프래그먼트 (Fragment) 컴포넌트가 무엇인가?

프래그먼트는 아무런 내용이 없는 빈 엘리먼트이다\
\
하나의 함수 컴포넌트는 하나의 루트 엘리먼트를 반환해야 한다. 그래서 div등을 루트 엘리먼트로 활용해서 다른 엘리먼트를 랩핑하는 패턴을 활용했는데 프래그먼트 컴포넌트를 사용하면 보다 깔끔하게 코드를 표현할 수 있다\
\
프래그먼트 컴포넌트는 html상에 표현되는 컴포넌트가 아니며 리액트에서 루트 엘리먼트를 표기하기 위한 용도로만 사용된다\
\
[공식링크](https://ko.reactjs.org/docs/fragments.html)

### Q. 리액트 블럭 (React.block)이 무엇인가 ?

워커 스레드가 메인스레드를 방해해서는 안된다. 그걸 위해서 리액트 블럭이 생겨났다\
\
리액트 블럭은 코드와 데이터를 동시에 로드하는 메커니즘입니다\
-- dan\
https://github.com/facebook/react/issues/17413\
\
dan이 말한다\
\
I don’t see relation to “VDOM” here. Or any difference between insertion/deletion/updates.\
The point is just that if your re-render, for one reason or another, includes hundreds of components, their code needs to run.\
Their code is arbitrary. We want it to not block the thread.\
We want it to not block the thread.\
이건 한마디로 메인스레드를 보호하자는 취지이다

---

###  훅 (React hooks)

### 커스텀 훅이란 ?

기본적인 훅인 useState나 useEffect등의 훅을 재조합해서 하나의 훅을 만드는 패턴이다. 이 커스텀 훅은 하나의 함수로 구성되며 함수 컴포넌트 내부에서 호출하여 사용한다

### useEffect

The function will run after the render is committed to the screen
유즈이펙트의 이펙트 함수는 렌더링과정이 완전히 종료된 이후에 실행되는가 ? 대부분의 문서는 그렇게 말하고 있다

### useLayoutEffect

이펙트 함수가 리액트 스케줄러에 의해 비동기로 발생하는 것 과는 다르게 useLayoutEffect는 diff알고리즘이 종료되고 가상돔이 실제돔에 직접적인 변경을 가한 이후에 동기적으로 바로 실행된다\
즉 하나의 렌더링 사이클 과정이 진행되는 자바스크립트 코드에서 동기적으로 실행된다

### useCallback

```javascript
function callback(a, b){}

const memoizedCallback = useCallback(
    callback,
    [a, b],
);
```
메모이제이션 기능이 추가된 함수를 반환한다. 첫번쨰 인자로 메모이즈할 콜백함수가 들어가고 두번째 인자는 콜백함수의 인자이다. 만일 콜백함수의 인자가 변경되면 콜백함수가 재생성된다. 만일 콜백함수의 인자가 변경되지 않으면 기존에 생성해놓은 함수의 참조값을 `memoizedCallback`변수에 재할당한다\
\
Q. 함수를 재생성하지 않는게 무슨 의의가 있는가 ?\
A. 모른다


###  useMemo
usememo는 속도 최적화에 사용된다\
useMemo는 그저 함수의 메모이제이션이다.
```javascript
const 메모된값 = useMemo(() => 함수(a, b), [a, b]);
```
별달리 설명할 내용이 없다

### useRef
useRef는 html엘리먼트에 접근할 때 사용한다. 리액트에서는 document.querySelector같은 셀렉터 함수 대신 ref를 이용하여 html엘리먼트를 컨트롤한다.\
주로 스타일이나 어트리뷰트 값을 조작할 때 사용한다

### forwardRef
외부 컴포넌트에서 다른 컴포넌트에 속해있는 html 엘리먼트에 접근할 때 사용한다\
왜 외부 컴포넌트에서 다른 컴포넌트에 참견을 하는가? 이건 아이솔레이션 위반이다. 하지만 편의성 등의 문제로 이런 상황이 필요할 때가 있다. 주로 포커싱 등의 상황에서 필요하다.\
forwardRef는 고차 컴포넌트인데 즉 인자로 컴포넌트를 받아서 다른 컴포넌트를 리턴한다. 이때 반환된 컴포넌트는 props외에도 ref라는 두번째 파라메터를 받는다. 이 두번째 파라메터가 외부에서 주입받는 ref이다

### useImperativeHandle

이름만 보고서는 사용법을 유추하기 어려운 `useImperativeHandle` 훅은 외부에서 전달받은 ref를 html엘리먼트에 직접적으로 쓰지않고 하나의 이벤트로서 활용하기 위해서 쓴다. 말이 어려운데 하나씩 풀어서 설명해보자\
\
만일 외부에서 전달받은 ref에 어떤 이벤트가 발생하면 그 이벤트를 이벤트리스너가 듣는다. 그 이벤트리스너의 이름이 useImperativeHandle이다.\
\
이벤트리스너가 특정한 이벤트를 감지하면 컴포넌트 내부에서 생성한 ref를 기반으로 html엘리먼트를 컨트롤한다\
\
이짓을 왜 하는가? 바로 외부에서 넘겨받은 ref에 컴포넌트의 통제권을 넘겨주지 않기 위해서이다.\
\
만일 외부에서 건내받은 ref가 내 컴포넌트에 이런저런 짓을 마음대로 할 수 있다면 단일 컴포넌트로서의 아이솔레이션이 훼손된다.\
\
그러므로 최대한 아이솔레이션을 유지하려면 최종적으로 특정 컴포넌트의 html을 조작하는 권한은 자기 자신이 가지고 있는편이 좋다. 이것을 가능하게 해주는 것이 useImperativeHandle이다.\
\
다시 말해서 useImperativeHandle은 엘리먼트의 조작 권한을 컴포넌트 자기자신이 보유하게 해준다

### useDebugValue

### useTransition

유즈 트랜지션은 서스펜스 컴포넌트의 fallback을 보여주지 않기위한 용도로 고안되었다\
\
화면이 다른 화면으로 전환될 때 화면에 나타나는 변화를 지연하고 싶은 경우에 사용한다. `React.lazy()`가 떠오른다면 정상이다\
\
실제로 서스펜스 컴포넌트 내부에서 리액트 레이지를 호출하는 방식으로 내부가 구현되어 있다\
\
먼저 유즈트랜지션을 사용하려면 가상돔을 렌더링 할 때 `ReactDom.render()` 대신에 `ReactDOM.createRoot()` 메소드를 사용해야 한다. \
\
크리에이트 루트라는 메소드는 생소하겠지만 이것을 호출해야 `컨커런트 모드`로 실행할 수 있다. 컨커런트 모드와 일반 모드는 리액트 스케줄러의 작동 메커니즘이 다르다\
\
그러니 이제는 ReactDOM.render()뿐만이 아니라 ReactDOM.createRoot()메소드에 익숙해지는 편이 좋다. 앞으로도 자주 보게 될 것이다\
\
유즈트랜지션의 문법은 아래와 같다

```javascript
const [startTransition, isPending] = useTransition({timeoutMs: 5000});
```

useTransition은 인자로 객체를 받는다. 객체는 timeoutMs를 프로퍼티로 가지는데 이 값은 트랜지션이 완료될 때까지 인내할 수 있는 시간이다.\
\
위의 예제에서는 값이 3000인데 이 말은 3000ms 즉 3초까지는 이전화면을 보여주고 만일 3초가 지났다면 로딩바를 보여주라는 뜻이다.\
\
즉 useTransition은 트랜지션 효과를 최대한 지연하고 싶을 때 사용하는 함수다.\
\
그러므로 useTransition보다는 useTransitionDelay라고 하는편이 더 정확하다. 어쩃든 로딩 상태창 등을 보여주고 싶지 않은 상황에 쓰이는 것이다.\
\
useTransition 훅은 배열을 리턴하는데 첫번째 원소를 startTransition 함수라고 한다. 그리고 두번째 원소를 isPending 변수라고 한다.\
\
먼저 간단한 isPending부터 설명하면 isPending은 이름이 시사하는 것처럼 불린 값이다. 트랜지션 상태가 펜딩(pending) 상태인지 리시디드(receded) 상태인지 여부를 알 수 있다. 펜딩 상태는 그저 트랜지션이 완료될 때 까지 기다리고 있는 상태다.\
\
startTransition 함수는 인자로 콜백을 받는다. 이 콜백 내부에서 setState류의 상태변화 함수를 호출하는데 이 상태변화에 반응하는 컴포넌트가 서스펜스 컴포넌트의 자식이라면 서스펜스 컴포넌트는 지정한 타임아웃 만료하기 전까지 fallback 엘리먼트를 보여주지 않는다.\
\
이것은 일반적인 서스펜스의 작동방식과 정 반대라고 볼 수 있다. 서스펜스 컴포넌트는 본래 로딩하는 과정에서 유저가 지루해하지 않도록 로딩 화면을 보여주려는 의도로 고안되었다. useTransition훅은 서스펜스 본래의 의도와는 정 반대의 작동을 수행하도록 유도하는 것이다\
\
유저가 로딩 시간을 참지 못하고 이탈할 수도 있을텐데 왜 로딩바를 보여주려 하지 않을까 ?  사실 로딩바를 보여주고 싶지 않은 상황이 있다\
\
이미 웹 페이지에 로딩 중에도 소비할 수 있는 충분한 컨텐츠가 있어서 오히려 로딩이라는 메시지가 방해로 작용하는 상황이 존재하는 것이다. 유즈트랜지션은 이런 상황에 쓰인다\
\
그러나 인내심에도 한계가 있는 것이어서 어떤 화면 전환이 너무 느릴 경우에는 유저가 짜증이 날 수 있다. 그래서 트랜지션에 최대 마감시간을 설정해 놓고 그 시간까지도 트랜지션이 완료되지 않는다면 그제서야 fallback을 보여주는 것이다.\
\
여담으로 서스펜스 컴포넌트에 `isFallback=false` 라는 식의 어트리뷰를 지정하는 편이 더 사용하기 수월하지 않겠나 싶지만 어째서인지 이렇게 하지 않고 `useTransition` 훅으로 이를 구현한 것으로 보인다.

[참고](https://ko.reactjs.org/docs/concurrent-mode-patterns.html)

### react-query

리액트 쿼리란 `전역상태를 터치하지 않는다(without touching any global state)`라는 슬로건을 가진 리액트 훅이다\
\
말 그대로 전역 스테이트를 건드리지 않은 상태에서 페치(fetch)를 수월하게 해주는 솔루션을 제공한다\
\
즉 리액트 쿼리의 지향점은 재사용 가능한 단일 리액트 컴포넌트로서의 아이솔레이션 기능을 유지하면서 fetch를 통한 최신의 상태를 손쉽게 유지하는 것이다.\
\
리액트 쿼리는 swr과 그 지향점이 유사하다. 그러니 굳이 swr을 사용할 줄 안다면 리액트 쿼리를 사용할 필요는 없을 것으로 보인다

[공식링크](https://react-query.tanstack.com/)

### swr

swr은 페치(fetch)하는 로직을 더 간단하게 도와주는 훅이다.\
\
페치하는 로직을 간단하게 해준다는 말이 애매할 수 있다. 예를 들어 데이터를 가져오기 전에 UI에 로딩이라고 적어두고 싶다.\
\
그리고 나서 페치가 완료되면 받아온 데이터를 기반으로 UI를 다시 그리고 싶다.\
\
이렇게 하려면 보통 하나의 상태를 만들어서 상태값이 `로딩`일 때는 로딩 컴포넌트를 렌더링하고 상태가 `응답완료`일 때는 받아온 데이터를 기반으로 렌더링한다.\
\
이건 구현 난이도가 어려운 건 아니지만 번거롭다. 반면 useSWR훅을 사용하면 일일이 상태를 변경할 필요 없이 직관적으로 구현할 수 있다.\
\
가령 아래와 같다

```javascript
 function App() {

  const { data, error } = useSWR(
    "https://api.github.com/repos/vercel/swr",
    fetcher
  );

  if (error) return "error";
  if (!data) return "Loading..";
  return (
    <>
      <h1>{data.name}</h1>
    </>
  );
}
```

위의 예제는 직관적이다. 이 컴포넌트는 서버에서 데이터를 받아오고 받아오는 동안은 로딩을 출력한다.\
\
받아온 뒤에는 데이터를 출력한다. 이걸 구현하는 과정에서 어떠한 상태도 사용하지 않았다. 그저 useSWR이 리턴하는 두개의 변수를 사용했을 뿐이다.\
\
swr은 이 외에도 두가지 기능을 추가로 더 제공한다 유저 인증과 게시판 로딩이다.\
\
먼저 유저 인증을 살펴보자. 해당 코드는 [여기](https://swr.vercel.app/examples/auth)에 있다.\
\
[swr에 대한 더 자세한 내용은 이 동영상](https://www.youtube.com/watch?v=F1o_0umlXbU)을 참조할 것

[swr 공식링크](https://swr.vercel.app/examples/basic)

###  Q. react-relay가 무엇인가?

`react-relay`는 클라이언트가 사용하는 그래프큐엘 훅이다\
\
그래프큐엘 기반의 데이터 페칭을 쉽게 관리할 수 있게 해준다\
\
릴레이는 빠른 속도와 편리한 사용방법이라는 두가지 장점을 모토로 한다\
\
하지만 릴레이 공식 웹페이지에서 제공하는 가장 간단한 예제를 살펴보면 사용법이 편리하다는 생각은 들기 어려울 것이다\
\
실제 예제를 살펴보자. 다음은 `usePreloadedQuery` 훅의 간단한 예제이다

```javascript

const relayEnvironment = new Environment({
  network: Network.create(커스텀_fetch함수),
  store: new Store(new RecordSource(), {
    gcReleaseBufferSize: 10
  })
});

const queryRef = loadQuery(
  relayEnvironment,
  TodoAppQuery.default,
  {userId: "me"}
) ;

const todoQuery =  graphql`
  query TodoAppQuery($userId: String!) {
    user(id: $userId) {
      id
      totalCount
      ...TodoListFooter_user
      ...TodoList_user
    }
  }
`

const data = usePreloadedQuery(
  todoQuery,
  queryRef
);
```

usePreloadedQuery훅은 그 이름의 의미하는 것 처럼 데이터를 미리 로드하는 기능을 제공한다.\
\
usePreloadedQuery훅은 두개의 인자를 받는다. 첫째는 그래프큐엘 기반의 쿼리 스트링인데 쿼리스트링을 인자로 받는것까지는 직관적이고 이해하기 쉽다.\
\
문제는 두번째 인자다. 두번째 인자는 loadQuery함수로 생성된 queryRef를 받는다.

### 이 문서는 작성중입니다

[relay 홈페이지](https://relay.dev/)

---

# react 18 관련

### 컨커런트 모드 (cuncurrent mode)
컨커런트 모드는 그저 서스펜스 컴포넌트를 사용하는 환경을 지칭할 뿐이다. 모든것이 서스펜스 컴포넌트가 있어야 수행될 수 있다.\
\
서스펜스 컴포넌트는 컴포넌트의 지연 렌더링에 사용하는 랩퍼 컴포넌트다

### 서스펜스(suspense) 컴포넌트

### 서스펜스리스트(SuspenseList) 컴포넌트

---

### 폼 컨트롤러

### 포믹 (formik)이란 ?

---


# css관련

###  css-in-js

css파일이 아닌 자바스크립트 파일 내부에서 css 규칙을 정의하는 코딩 스타일을 `css-in-js`라고 부른다.\
\
스타일드 컴포넌트같은 라이브러리가 대표적인 css-in-js의 예이다

### 테일윈드 css (tailwind css)

테일윈드를 이야기하기 앞서 부트스트랩 라이브러리를 이야기 해보자\
\
부트스트랩은 일일이 css 규칙을 정의하지 않아도 html 엘리먼트에 클래스 이름을 기입하는 것만으로 간편하게 사용할 수 있는 라이브러리이다. 이것이 가능한 이유는 부트스트랩 팀에서 미리 css 코드와 클래스 이름을 정의해놓았기 때문이다\
\
즉 부트스트랩을 사용하면 남이 만들어놓은 css를 그저 가져다 쓰면 될 뿐이므로 내가 css 규칙을 작성할 일이 거의 없다.\
\
부트스트랩에서 제공하는 클래스 이름만 암기하고 그 암기한 클래스 이름을 원하는 엘리먼트에 붙여넣으면 될 뿐이다\
\
그리고 이 부트스트랩의 후계자 정도 되는 라이브러리가 테일윈드 css라고 할 수 있다. 테일윈드 css도 부트스트랩과 마찬가지로 이미 정의되어 있는 css규칙을 사용한다. 유저는 그저 테일윈드에 정의되어 있는 클래스 이름을 암기하고 그 이름을 가져다가 특정 html 엘리먼트에 적용하기만 하면 되는 것이다.\
\
앞서 이야기했듯 내가 css규칙을 일일이 작성할 필요가 거의 없다는 점이 테일윈드 css의 가장 큰 장점이다. 극단적으로 말하면 프로젝트의 모든 스타일링을 테일윈드 만으로도 구현할 수 있다. 따라서 내가 작성해야 하는 css코드의 양을 제로로 줄일 수도 있다 \
\
하지만 단점으로는 클래스이름을 많이 적용하게 되면 코드가 너무 지저분해 지고 내가 어떤 속성을 적용했는지 한눈에 알아보기 어렵다는 단점이 있다. 이 단점은 극복이 거의 불가능하다. 이 치명적인 단점 때문에 테일윈드를 싫어하는 사람들이 많다\
\
그리고 암기해야 하는 클래스 이름이 많아 어느정도의 러닝커브가 있다. 테일윈드에 익숙해지기 전까지는 모니터 한켠에 테일윈드의 공식 docs 페이지를 띄어놓고 작업해야 한다

###  스타일드 컴포넌트(styled-components)란?

스타일드 컴포넌트는 css-in-js 패턴의 일종이다\
\
말 그대로 스타일이 적용된 컴포넌트를 생성한다\
\
함수 컴포넌트 내부에서 스타일 객체의 메소드를 호출하여 새로운 스타일이 적용된 컴포넌트를 반환한다\
\
아래 예는 스타일 객체에서 a메소드를 호출하여 새로운 스타일이 적용된 앵커 태그를 생성한다

```javascript
const AnchorTag = styled.a`
    color : red
` ;
```

이렇게 리턴된 컴포넌트는 일반적인 리액트 컴포넌트처럼 사용할 수 있다\
\
스타일드 컴포넌트가 주목받는 이유는 두가지 정도가 있다\
\
첫째로 함수 컴포넌트의 리턴부분이 깔끔해진다. html엘리먼트에 어떠한 클래스네임도 기입할 필요가 없기 때문이다\
\
두번째로 함수 컴포넌트의 완전한 고립화가 가능해진다. 외부의 css파일에서 css속성을 임포트하지 않아도 되므로 단일 파일 형태로 관리하기 쉽다. 이에 따라 자연스럽게 재사용성도 높아진다\
\
세번째로 레가시 코드를 새로운 css 프레임워크로 대체할 때 코드를 리팩토링할 필요가 없다. 앞서 말했듯 스타일드 컴포넌트가 적용된 리액트 컴포넌트는 완전한 고립화가 가능하므로 다른 컴포넌트에서 테일윈드 css등의 별개의 프레임워크를 사용한다 하더라도 충돌을 일으키지 않은 채 정상적으로 작동한다\
\
하지만 스타일드 컴포넌트는 css 정의와 리액트 컴포넌트 정의부분이 분리되지 않으므로 다른 컴포넌트에서 css 정의를 재사용하기 어렵다는 단점이 있다

### 함수 컴포넌트 내부에서 사용하는 `<style jsx>{""}` 같은 패턴을 뭐라고 부르는가 ?

이것은 스타일드 jsx(styled-jsx) 라고 부른다. 버셀(vercel)에서 개발한 스타일드 jsx 라이브러리는 함수 컴포넌트 내부에서 사용하는 `css-in-js` 패턴의 일종이다.\
\
스타일드 jsx에서 선언된 css 규칙은 해당 컴포넌트에만 국소적으로 적용된다.\
\
이는 스타일드 컴포넌트 라이브러와 유사하지만 둘 사이의 차이점이 있다.\
\
스타일드 jsx는 css규칙을 선언한 후에 html엘리먼트에도 클래스이름을 기입해야 하는 번거로움이 있다.\
\
하지만 스타일드 컴포넌트로 정의된 리액트 컴포넌트에는 별도의 클래스네임을 기입할 필요가 없다는 편의성이 있다.\
\
이런 면에서 보면 스타일드 jsx의 진화된 버전이 스타일드 컴포넌트라고 해석할 수도 있지만 꼭 스타일드 컴포넌트가 더 좋다고 볼 수는 없다\
\
왜냐하면 스타일드 컴포넌트는 코드부와 css정의부가 독립되기 않기 때문이다.\
\
코드부와 css정의부가 독립되는게 왜 중요한가?\
\
이들 둘이 분리되어 있는 경우에는 관심사의 분리가 이루어진 것이며 관심사가 분리된 경우에는 코드의 유지보수가 더 수월해진다\
\
css 디피니티브 가이드(css definitive guide)의 공저자인 에스텔 웨일(Estelle Weyl)은 css와 js코드가 분리되어야 한다고 주장했는데 그렇게 해야하는 이유는 레이어를 분리하기 위함이다.\
\
애초에 웹을 구성하는 도구가 html, css, javascript의 3가지로 나뉜것도 레이어를 분리해서 유지보수를 수월하게 하기 위함이었다고 그녀는 말한다.\
\
구체적으로 이야기하면 css는 표현 계층(presentational layer)의 구현체이며 자바스크립트는 행동 계층(Behavioral layer)의 구현체이다.\
\
이들 둘이 분리된건 우연이 아니며 의도적인 것이었다.\
\
그런데 오늘날 `css-in-js`를 통하여 표현 계층과 행동 계층을 합병하려 하고 있으니 이것은 썩 바라짐하지 못하다고 그녀는 이야기하고 있는 것이었다.\
\
그러므로 우리는 외부에서 css를 항상 임포트해서 써야 하는가? 리액트의 관점에서 보면 그것도 썩 바람직하다고는 볼 수 없는 것이다.\
\
왜냐하면 그것은 단일 파일이 하나의 컴포넌트로 완결성을 지니는 고립성(isolation)을 해치기 때문이다.\
\
그런 관점에서 볼 때 스타일드 jsx는 레이어의 분리와 컴포넌트의 고립성을 보장하면서 어느정도는 레이어를 분리시키는 이 두가지 원칙의 절충점이라고 볼 수 있다\
\
비록 스타일드 jsx가 js파일 내부에서 사용된다고는 할지라도 단일 jsx구문은 코드에 산발적으로 흩어져있지 않으며 한곳에 응집되어 있다\
\
따라서 이리저리 css코드를 찾으러 헤메일 필요가 없는 것이다.\
\
이런면에서 볼 때 어느정도는 레이어의 분리가 성립되었다고도 평가할 수 있는 것이다\
\
결론을 말하면 완전한 레이어의 분리를 유지하여 개발하고 싶다면 css 모듈이 적합하고 리액트 컴포넌트를 단일 파일로 고립시킨 상태에서 어느정도의 레이어의 분리를 원한다면 스타일드 jsx가 적합하다


### css module

css 모듈은 특정 컴포넌트에만 국소적으로 스타일을 적용하는 css 테크닉이다\
\
css 모듈은 일반적인 css 임포트 (import) 패턴과 거의 같은 패턴이므로 새롭게 배울 내용은 거의 없다\
\
다만 css 파일명은 `컴포넌트명.module.css`과 같은 포멧으로 작성한다\
\
그리고 css를 적용할 때는 임포트된 css 모듈에 프로퍼티로 정의된 클래스 이름을 사용한다\
\
클래스명이나 아이디 어트리뷰트를 css 식별자로 사용할 수 있지만 아이디 사용은 권장하지 않는다. 아이디는 유니크한 값이므로 적용할 수 있는 엘리먼트가 매우 제한적이기 때문이다\
\
같은 css모듈을 사용하더라도 임포트 할 때마다 고유한 클래스 이름이 생성되어 다른 컴포넌트에서 같은 css 모듈을 사용한다고 해도 클래스명이 겹칠 일은 없다\
\
이것이 특정 컴포넌트에만 국소적으로 스타일을 적용하게 해주는 핵심 원리다\

### Q. `css 모듈`에 안티 패턴이 있는가?
A. 부모 컴포넌트에서 생성된 클래스네임을 자식 컴포넌트로 상속하지 않는 편이 좋다.\
\
CSS 모듈을 임포트하고 나서 해당 모듈에서 제공하는 클래스네임을 자식 컴포넌트에 프롭스로  전달하지 않는 편이 좋다.\
\
만일 css 모듈 파일에서 클래스 이름을 변경했을 때 단일 컴포넌트에서만 사용하는 경우 클래스 네임의 변경은 쉽다. 그저 IDE를 켜고 일괄적으로 이름바꾸기 기능을 사용하면 10초 내외로 끝나는 작업이다.\
\
하지만 불특정 다수의 자식 컴포넌트에서 해당 클래스 이름을 가져다가 사용하는 경우는 자식 컴포넌트가 정의된 모든 파일을 순회하며 클래스 이름을 변경해줘야 하는 번거로움이 발생한다

### sass(Syntactically Awesome Stylesheets) 란 ?

사스는 css의 변종 언어이며 이 언어는 빌드 과정에서 css로 트랜스파일 된다\
\
사스는 css 표준 문법보다 더욱 프로그래밍 언어스럽게 개발할 수 있다는 장점이 있다. 즉 사스는 변수, 믹스인, 중첩과 같은 기능을 제공한다. 이러한 기능들은 개발의 편의성을 제공한다\
\
요즘은 css 표준에도 변수같은 기능이 추가되어 사스를 사용할 이유가 점차 줄어들고 있기는 하다

---

# 기타 후순위

### react-fetch
자료가 없음

### useSelectedContext
context api의 대안으로 등장했다. 퍼포먼스 이슈를 어느정도 해결한 것으로 보임\
현재 관련 구현제는 dai-shi가 구현하였음

###  react fiber란 무엇인가 ?

#### 리액트 컴포넌트에 key 어트리뷰트는 왜 기입하는가?
참고 : https://stackoverflow.com/questions/45981597/how-does-react-key-works
