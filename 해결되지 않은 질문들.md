# 해결되지 않은 질문들 모음

---
##  일반 질문

###  증분형 돔(incremental DOM)이란 무엇인가?
증분형 돔은 리액트에서 고안된 개념은 아니다. 증분형 돔은 앵귤러에서 관리하는 돔이다

---

### 폼 컨트롤러

### 포믹 (formik)이란 ?
참고 : https://formik.org/docs/overview

### react hook form
참고 : https://react-hook-form.com/

## 테스트 관련

### Q. 퍼핏티어에서 주로 사용하는 기능이 있는가
slowMo 옵션은 특정 동작을 수행할 때 지정한 시간만큼 지연시킨다\
또한 원하는 윈도우 크기를 지정하여 테스트할 수 있는데 이는 반응형 페이지를 테스트할 때 효과적이다

### 행위 기반 개발 (Behaviour-Driven Development,BDD)이란 무엇인가?
BDD는 TDD에 기반을 두고 있다. 하지만 BDD는 함수 단위로 테스트가 진행되지 않는다

### Q. cucumber.js란 무엇인가?
cucumber.js는 BDD를 수행하는 라이브러리다

---

## 디자인 패턴 관련

### Q. 함수로서의 자식 컴포넌트(Function as Child Components) 패턴이란 무엇인가 ?
A. 답을 찾는 중
참고 : https://americanexpress.io/faccs-are-an-antipattern/

### 함수 컴포넌트의 리턴문에 js로직을 삽입하는 것은 안티패턴인가 ?
### 프롭스 드릴링(Prop drilling)은 안티패턴인가?

### `버튼이 아닌 엘리먼트에 onClick어트리뷰트 사용하기`는 안티패턴인가 ?
### 배열의 요소를 map등으로 렌더링할 때 왜 키(key)어트리뷰트가 필요한가?

### 함수 컴포넌트 내부의 함수 컴포넌트

```javascript
function Component() {
  function ScopedComponent() {
    // ...
  }
  return <ScopedComponent />
}
```
#### 왜 루프문에서 인덱스를 키(key)로 사용하는 패턴이 안티패턴인가 ?
We don’t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. When you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort
항목의 순서가 변경될 수 있는 경우 키에 인덱스를 사용하지 않는 것이 좋습니다. 이로 인해 성능에 부정적인 영향을 미칠 수 있으며 구성 요소 상태에 문제가 발생할 수 있습니다. 렌더링된 항목의 안정적인 ID가 없는 경우 마지막 수단으로 항목 색인을 사용할 수 있습니다.
https://reactjs.org/

키는 유니크 해야하기 때문이다. 만일 키가 유니크하지 않으면 렌더링 과정에서 성능저하 현상이 발생할 수 있다
https://medium.com/@suraj.kc/react-anti-patterns-909ecf193701

### Q. 왜 리액트는 MVC가 아닌가?

리액트 코어팀은 양방향 데이터 플로우를 싫어했다.\
\
앵귤러 등의 양방향 데이터 플로우를 지원하는 MVC계열 프레임워크는 데이터의 이동을 추적하기 어려웠다. 그래서 디버깅이 어려웠고 많은 사람들이 떠났다.\
\
리액트 팀은 데이터를 쉽게 추적할 수 있고 그 결과 디버깅도 쉬워지는 단방향 데이터 흐름을 선호했다.\
\
이러한 패러다임을 기반으로 탄생한 플럭스 아키텍처는 기존의 MVC모델과는 다른 접근방식을 지향했다\
\
즉 리액트는 뷰와 모델간의 양방향 데이터 흐름을 지원하지 않기 때문에 MVC라고 보기 어렵다

### 리액트에서 믹스인(mixin) 패턴이란 무엇인가?

믹스인은 서로 다른 두개의 컴포넌트가 일부 코드를 공유하는 코딩 패턴을 말한다.\
\
이는 클래스 컴포넌트의 상속 기능을 통해 구현된다.\
\
부모 컴포넌트가 있고 자식 컴포넌트가 부모 컴포넌트를 상속받아서 구현되었다고 가정해 보자.\
\
부모가 자식을 상속했으므로 부모와 자식 컴포넌트는 일부 코드를 공유한다.\
\
이같은 상황에서 부모 컴포넌트를 수정하기는 매우 조심스러운 일이다. 부모 컴포넌트를 수정하려면 자식 컴포넌트의 동작까지 고려해야 한다\
\
결론적으로 리액트에서 믹스인은 유해한 것으로 간주된다. 왜냐하면 믹스인을 적용할 경우 단일 컴포넌트는 단독적으로 수정할 수도 없으며 여러 수많은 컴포넌트를 고려하여 설계되어야 하기 떄문이다\
\
상세는 [링크](https://ko.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)를 참조하시오

##### 프롭스(props)를 디컨스트럭팅 하여 자식 컴포넌트에게 인자로 넘겨주는 패턴이 옮은가 옮지 않은가 ?
이것은 편의성 면에서는 권장할 만 하다. 하지만 가독성 면에서는 좋지 않다. 구체적으로 어떤 인자가 입력되었는지 명시적으로 확인하기 어렵기 때문이다. 하지만 props 객체를 바로 위의 코드에서 확인할 수 있는 경우에는 크게 문제되지 않는다. 가령 아래와 같다

```javascript
const props = {
    이름 : "김삿갓",
    나이 : 18,
    거주지 : "서울",
}

return (
    <Component {...props}>
)
```

---

### 리액트 컴포넌트

### Q. 프로파일러 (profiler) 컴포넌트가 무엇인가 ?

프로파일러 컴포넌트는 일종의 랩퍼 컴포넌트인데 이는 자식 컴포넌트의 렌더링 코스트를 계산한다\
\
프로파일러 컴포넌트는 `<Profiler></Profiler>`와 같이 기입해서 사용한다. 구체적인 예시는 아래와 같다

```javascript
  <Profiler id="nav" onRender={callback}>
    <Navigation {...props} />
  </Profiler>

```

### Q. 리액트 블럭 (React.block)이 무엇인가 ?

워커 스레드가 메인스레드를 방해해서는 안된다. 그걸 위해서 리액트 블럭이 생겨났다\
\
리액트 블럭은 코드와 데이터를 동시에 로드하는 메커니즘입니다\
-- dan\
https://github.com/facebook/react/issues/17413\
\
dan이 말한다\
\
I don’t see relation to “VDOM” here. Or any difference between insertion/deletion/updates.\
The point is just that if your re-render, for one reason or another, includes hundreds of components, their code needs to run.\
Their code is arbitrary. We want it to not block the thread.\
We want it to not block the thread.\
이건 한마디로 메인스레드를 보호하자는 취지이다

---

###  훅 (React hooks)

### 커스텀 훅이란 ?

기본적인 훅인 useState나 useEffect등의 훅을 재조합해서 하나의 훅을 만드는 패턴이다. 이 커스텀 훅은 하나의 함수로 구성되며 함수 컴포넌트 내부에서 호출하여 사용한다

##### ErrorBoundary 컴포넌트
네트워크 장애 같은 이유로 다른 모듈의 로드에 실패할 경우 에러가 발생할 수 있다\
\
이때 에러바운더리 컴포넌트를 이용하여 사용자 경험을 관리하면 복구 세션을 수행할 수 있다.\
\
에러 바운더리 컴포넌트를 생성하고 레이지(Lazy) 컴포넌트를 자식 컴포넌트로 포함시키면 네트워크 장애가 발생했을 때 적절한 조치를 취할 수 있게된다

### useCallback

```javascript
function callback(a, b){}

const memoizedCallback = useCallback(
    callback,
    [a, b],
);
```
메모이제이션 기능이 추가된 함수를 반환한다. 첫번쨰 인자로 메모이즈할 콜백함수가 들어가고 두번째 인자는 콜백함수의 인자이다. 만일 콜백함수의 인자가 변경되면 콜백함수가 재생성된다. 만일 콜백함수의 인자가 변경되지 않으면 기존에 생성해놓은 함수의 참조값을 `memoizedCallback`변수에 재할당한다\
\
Q. 함수를 재생성하지 않는게 무슨 의의가 있는가 ?\
A. 모른다


###  useMemo
usememo는 속도 최적화에 사용된다\
useMemo는 그저 함수의 메모이제이션이다.
```javascript
const 메모된값 = useMemo(() => 함수(a, b), [a, b]);
```
별달리 설명할 내용이 없다

### useDebugValue

---

## 서드파티 리액트 훅
### react-query

리액트 쿼리란 `전역상태를 터치하지 않는다(without touching any global state)`라는 슬로건을 가진 리액트 훅이다\
\
말 그대로 전역 스테이트를 건드리지 않은 상태에서 페치(fetch)를 수월하게 해주는 솔루션을 제공한다\
\
즉 리액트 쿼리의 지향점은 재사용 가능한 단일 리액트 컴포넌트로서의 아이솔레이션 기능을 유지하면서 fetch를 통한 최신의 상태를 손쉽게 유지하는 것이다.\
\
리액트 쿼리는 swr과 그 지향점이 유사하다. 그러니 굳이 swr을 사용할 줄 안다면 리액트 쿼리를 사용할 필요는 없을 것으로 보인다

[공식링크](https://react-query.tanstack.com/)

### swr

swr은 페치(fetch)하는 로직을 더 간단하게 도와주는 훅이다.\
\
페치하는 로직을 간단하게 해준다는 말이 애매할 수 있다. 예를 들어 데이터를 가져오기 전에 UI에 로딩이라고 적어두고 싶다.\
\
그리고 나서 페치가 완료되면 받아온 데이터를 기반으로 UI를 다시 그리고 싶다.\
\
이렇게 하려면 보통 하나의 상태를 만들어서 상태값이 `로딩`일 때는 로딩 컴포넌트를 렌더링하고 상태가 `응답완료`일 때는 받아온 데이터를 기반으로 렌더링한다.\
\
이건 구현 난이도가 어려운 건 아니지만 번거롭다. 반면 useSWR훅을 사용하면 일일이 상태를 변경할 필요 없이 직관적으로 구현할 수 있다.\
\
가령 아래와 같다

```javascript
 function App() {

  const { data, error } = useSWR(
    "https://api.github.com/repos/vercel/swr",
    fetcher
  );

  if (error) return "error";
  if (!data) return "Loading..";
  return (
    <>
      <h1>{data.name}</h1>
    </>
  );
}
```

위의 예제는 직관적이다. 이 컴포넌트는 서버에서 데이터를 받아오고 받아오는 동안은 로딩을 출력한다.\
\
받아온 뒤에는 데이터를 출력한다. 이걸 구현하는 과정에서 어떠한 상태도 사용하지 않았다. 그저 useSWR이 리턴하는 두개의 변수를 사용했을 뿐이다.\
\
swr은 이 외에도 두가지 기능을 추가로 더 제공한다 유저 인증과 게시판 로딩이다.\
\
먼저 유저 인증을 살펴보자. 해당 코드는 [여기](https://swr.vercel.app/examples/auth)에 있다.\
\
[swr에 대한 더 자세한 내용은 이 동영상](https://www.youtube.com/watch?v=F1o_0umlXbU)을 참조할 것

[swr 공식링크](https://swr.vercel.app/examples/basic)

###  Q. react-relay가 무엇인가?

`react-relay`는 클라이언트가 사용하는 그래프큐엘 훅이다\
\
그래프큐엘 기반의 데이터 페칭을 쉽게 관리할 수 있게 해준다\
\
릴레이는 빠른 속도와 편리한 사용방법이라는 두가지 장점을 모토로 한다\
\
하지만 릴레이 공식 웹페이지에서 제공하는 가장 간단한 예제를 살펴보면 사용법이 편리하다는 생각은 들기 어려울 것이다\
\
실제 예제를 살펴보자. 다음은 `usePreloadedQuery` 훅의 간단한 예제이다

```javascript

const relayEnvironment = new Environment({
  network: Network.create(커스텀_fetch함수),
  store: new Store(new RecordSource(), {
    gcReleaseBufferSize: 10
  })
});

const queryRef = loadQuery(
  relayEnvironment,
  TodoAppQuery.default,
  {userId: "me"}
) ;

const todoQuery =  graphql`
  query TodoAppQuery($userId: String!) {
    user(id: $userId) {
      id
      totalCount
      ...TodoListFooter_user
      ...TodoList_user
    }
  }
`

const data = usePreloadedQuery(
  todoQuery,
  queryRef
);
```

usePreloadedQuery훅은 그 이름의 의미하는 것 처럼 데이터를 미리 로드하는 기능을 제공한다.\
\
usePreloadedQuery훅은 두개의 인자를 받는다. 첫째는 그래프큐엘 기반의 쿼리 스트링인데 쿼리스트링을 인자로 받는것까지는 직관적이고 이해하기 쉽다.\
\
문제는 두번째 인자다. 두번째 인자는 loadQuery함수로 생성된 queryRef를 받는다.

### 이 문서는 작성중입니다

[relay 홈페이지](https://relay.dev/)

---

# react 18 관련

### 컨커런트 모드 (cuncurrent mode)
컨커런트 모드는 그저 서스펜스 컴포넌트를 사용하는 환경을 지칭할 뿐이다. 모든것이 서스펜스 컴포넌트가 있어야 수행될 수 있다.\
\
서스펜스 컴포넌트는 컴포넌트의 지연 렌더링에 사용하는 랩퍼 컴포넌트다


##### 서스펜스(suspense) 모드 (suspense, concurrent mode, SSR Streaming)
Concurrent features in React 18 include built-in support for server-side Suspense and SSR streaming support, allowing you to server-render pages using HTTP streaming.
[출처](https://nextjs.org/docs/advanced-features/react-18)

This also means that you can use Suspense-based data-fetching, next/dynamic, and React's built-in React.lazy with Suspense boundaries.

### 서스펜스(suspense) 컴포넌트

### 서스펜스리스트(SuspenseList) 컴포넌트

---

---

# 기타 후순위

### react-fetch
자료가 없음

### useSelectedContext
context api의 대안으로 등장했다. 퍼포먼스 이슈를 어느정도 해결한 것으로 보임\
현재 관련 구현제는 dai-shi가 구현하였음

###  react fiber란 무엇인가 ?

#### 리액트 컴포넌트에 key 어트리뷰트는 왜 기입하는가?
참고 : https://stackoverflow.com/questions/45981597/how-does-react-key-works