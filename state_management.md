# 상태관리 관련 Q&A

#### Q. 플럭스(flux) 아키텍처가 뭔가?

A. 클라이언트 사이드에서 웹 앱을 만드는데 사용하는 아키텍처이다. 단방향으로 데이터가 흐른다는 점이 특징이다\
데이터가 단방향으로 흐르는 이유는 데이터의 변이를 관찰하기 쉽게 만들어 디버깅을 쉽게 하기 위함이다

상세는 https://facebook.github.io/flux/docs/in-depth-overview/ 를 참조하시오

#### Q. redux와 flux는 같은 개념인가?

A. 비슷한 개념이지만 같은 개념은 아니다. 아키텍처 구조가 약간 다르다.\
플럭스에서는 여러개의 스토어를 생성할 수 있지만 리덕스에서는 단일 스토어에서 데이터가 관리된다\
단일 스토어를 사용하는 이유는 단순한 환경에서 디버깅을 쉽게 하기 위함이다

#### Q. 리덕스(redux)를 어떻게 쓰는가?

A. 리액트에서 리덕스를 쓰려면 react-redux라이브러리를 사용하면 된다\
상세는 https://react-redux.js.org/api/hooks 를 참조하시오

#### Q. 리덕스를 리액트와 연동해서 쓰려면 어떻게 해야하는가?

A. npm에서 react-redux를 다운받아서 사용할 수 있다\
먼저 최상단 루트 컴포넌트에 프로바이더(Provider) 컴포넌트를 생성하고 나서 상태가 필요한 각각의 컴포넌트에 createStore와 useSelector등의 함수를 이용하여 사용한다

#### Q. 리덕스 사가(redux saga)가 무엇인가?

A. 리덕스 사가는 fetch등의 비동기 작업에 쓰인다\
리덕스 사가는 리덕스와 메커니즘이 거의 비슷하다. 액션, 디스패처 등 거의 모든것이 같다\
리덕스와 리덕스사가의 차이는 비동기로 작동하느냐 동기로 작동하느냐의 차이 정도이다\
그러므로 리덕스 사가는 fetch등의 비동기 프로세스를 수행할 때 사용한다. 이 때 제네레이터로 비동기 로직을 작성하는데 거의 async 함수와 비슷한 형태로 작성한다

#### Q. xstate가 무엇인가?

A. 유한상태머신의 구현체이다. 리액트에 적용해서 사용할 수 있다\
상세는 https://xstate.js.org/ 를 참조하시오

#### Q. xstate를 어떻게 쓰는가?

A. 먼저 상태머신을 만든다\
이 때 상태머신이 가질 수 있는 모든 상태들을 정의해야 한다\
상태를 만든 다음에는 그 상태머신을 스타트하여 상태머신이 작동하도록 한다\
이후에는 이 상태머신에 상태를 보내주면 된다.\
상태머신이 특정 상태로 변한 것을 감지하면 해당 상태와 연결된 콜백함수를 호출한다\
이 상태전환을 토글이라고 한다. 즉 토글되면 변경된 상태와 관련된 콜백이 호출된다\

### 리덕스란 무엇인가 ?

리덕스의 모든 작업은 디스패처를 통해서만 이루어진다. 즉 모든 변화는 단일한 게이트 키퍼인 디스패처를 반드시 통과해야 한다.

리덕스는 flux와 elm아키텍처를 혼용하여 제작되었다.

dan이 말하길, 이것을 도입한 이유는 flux 아키텍처를 수정하면 핫 리로딩과 타임 트래블을 구현할 수 있지 않을까? 하는 가설을 입증하기 위하여 고안되었다.

다시 말해 거시적인 그림은 flux아키텍처와 큰 차이가 ㅇ ㅓㅄ다.

dan이 말하길,  redux is just an event emitter. a change emitter holding a value

이벤트 emitter는 상태변경이라는 이벤트를 emit하여 스케줄러에 전달한다.

### 그러면 flux란 무엇인가 ?

페북 개발자가 말하길 , flux는 making interactions easier to reason about 때문에 만들었다고 한다

### 그래프큐엘 (GraphQL)

그래프큐엘은 하나의 문제에서 출발한다. 바로 REST API가 가진 문제점이다.\
레스트 API는 문제가 있었다. `The Big problem was a lack of modularity` 였다. 그래프큐엘은 모듈화를 가능케 한 것으로 추정된다. 무엇에 대한 모듈화인지는 모르겠지만 .. 아무튼 코어 컨셉은 반응의 형태를 구조적 형태로 구성할 수 있다는 점이다. 구조적인 형태는 트리 구조를 표현할 수 있다는 뜻이다.\
트리구조로 데이터를 모듈화 할 수 있다고 한다. 그런데 이게 왜 좋은가 ? 컴포넌트 단윈로 필요한 데이터를 모듈화하여 불필요한 정보를 요청하지 않아도 된다는 이점이 있다는데 불필요한 정보의 요청은 레스트 api를 사용해도 피할 수 있지 않은가 ?

### react-query

리액트 쿼리란 `전역상태를 터치하지 않는다(without touching any global state)`라는 슬로건을 가진 리액트 훅이다\
\
말 그대로 전역 스테이트를 건드리지 않은 상태에서 페치(fetch)를 수월하게 해주는 솔루션을 제공한다\
\
즉 리액트 쿼리의 지향점은 재사용 가능한 단일 리액트 컴포넌트로서의 아이솔레이션 기능을 유지하면서 fetch를 통한 최신의 상태를 손쉽게 유지하는 것이다.\
\
리액트 쿼리는 swr과 그 지향점이 유사하다. 그러니 굳이 swr을 사용할 줄 안다면 리액트 쿼리를 사용할 필요는 없을 것으로 보인다

[공식링크](https://react-query.tanstack.com/)

### swr

swr은 페치(fetch)하는 로직을 더 간단하게 도와주는 훅이다.\
\
페치하는 로직을 간단하게 해준다는 말이 애매할 수 있다. 예를 들어 데이터를 가져오기 전에 UI에 로딩이라고 적어두고 싶다.\
\
그리고 나서 페치가 완료되면 받아온 데이터를 기반으로 UI를 다시 그리고 싶다.\
\
이렇게 하려면 보통 하나의 상태를 만들어서 상태값이 `로딩`일 때는 로딩 컴포넌트를 렌더링하고 상태가 `응답완료`일 때는 받아온 데이터를 기반으로 렌더링한다.\
\
이건 구현 난이도가 어려운 건 아니지만 번거롭다. 반면 useSWR훅을 사용하면 일일이 상태를 변경할 필요 없이 직관적으로 구현할 수 있다.\
\
가령 아래와 같다

```javascript
 function App() {

  const { data, error } = useSWR(
    "https://api.github.com/repos/vercel/swr",
    fetcher
  );

  if (error) return "error";
  if (!data) return "Loading..";
  return (
    <>
      <h1>{data.name}</h1>
    </>
  );
}
```

위의 예제는 직관적이다. 이 컴포넌트는 서버에서 데이터를 받아오고 받아오는 동안은 로딩을 출력한다.\
\
받아온 뒤에는 데이터를 출력한다. 이걸 구현하는 과정에서 어떠한 상태도 사용하지 않았다. 그저 useSWR이 리턴하는 두개의 변수를 사용했을 뿐이다.\
\
swr은 이 외에도 두가지 기능을 추가로 더 제공한다 유저 인증과 게시판 로딩이다.\
\
먼저 유저 인증을 살펴보자. 해당 코드는 [여기](https://swr.vercel.app/examples/auth)에 있다.\
\
[swr에 대한 더 자세한 내용은 이 동영상](https://www.youtube.com/watch?v=F1o_0umlXbU)을 참조할 것

[swr 공식링크](https://swr.vercel.app/examples/basic)

###  Q. react-relay가 무엇인가?

`react-relay`는 클라이언트가 사용하는 그래프큐엘 훅이다\
\
그래프큐엘 기반의 데이터 페칭을 쉽게 관리할 수 있게 해준다\
\
릴레이는 빠른 속도와 편리한 사용방법이라는 두가지 장점을 모토로 한다\
\
하지만 릴레이 공식 웹페이지에서 제공하는 가장 간단한 예제를 살펴보면 사용법이 편리하다는 생각은 들기 어려울 것이다\
\
실제 예제를 살펴보자. 다음은 `usePreloadedQuery` 훅의 간단한 예제이다

```javascript

const relayEnvironment = new Environment({
  network: Network.create(커스텀_fetch함수),
  store: new Store(new RecordSource(), {
    gcReleaseBufferSize: 10
  })
});

const queryRef = loadQuery(
  relayEnvironment,
  TodoAppQuery.default,
  {userId: "me"}
) ;

const todoQuery =  graphql`
  query TodoAppQuery($userId: String!) {
    user(id: $userId) {
      id
      totalCount
      ...TodoListFooter_user
      ...TodoList_user
    }
  }
`

const data = usePreloadedQuery(
  todoQuery,
  queryRef
);
```

usePreloadedQuery훅은 그 이름의 의미하는 것 처럼 데이터를 미리 로드하는 기능을 제공한다.\
\
usePreloadedQuery훅은 두개의 인자를 받는다. 첫째는 그래프큐엘 기반의 쿼리 스트링인데 쿼리스트링을 인자로 받는것까지는 직관적이고 이해하기 쉽다.\
\
문제는 두번째 인자다. 두번째 인자는 loadQuery함수로 생성된 queryRef를 받는다.

### 이 문서는 작성중입니다

[relay 홈페이지](https://relay.dev/)


##### context 컴포넌트

컨텍스트 컴포넌트는 `상태 끌어올리기(lift state up)`를 위한 솔루션이다\
두개의 컴포넌트가 부모-자식 관계가 아닌 상태에서 데이터를 공유할 때 공통의 조상에게 데이터를 위임하여 그 조상으로부터 데이터를 넘겨받는 패턴이다. 이 때 데이터를 가진 조상 컴포넌트는 최소 공통 조상에게 넘겨주는게 관례이다. 그 이유는 퍼포먼스 때문인데 컨텍스트 API가 루트 컴포넌트에 가깝게 위로 올라갈수록 렌더링 속도의 저하 문제가 있기 때문이다\
컨텍스트 API를 적용했다면 스테이트가 변경된 경우 이 스테이트를 렌더링하는 모든 컴포넌트가 재랜더링된다

[lift state up 참고](https://ko.reactjs.org/docs/lifting-state-up.html)

# 리코일 Q&A

#### Q. 리코일이 뭔가?

A. 리코일은 상태관리 라이브러리다

#### Q. 리코일 사용법을 간단하게 소개해줄 수 있는가?
A. 리액트에는 useState라는 훅이 있다. 이 훅은 상태를 저장하고 변경할 수 있다\
리코일에도 useState와 비슷한 훅이 있다. 그것이 useRecoilState이다

#### Q. useRecoilState는 useState쓰듯이 사용하면 되는가?

A. 거의 비슷한데 함수가 인자로 받는 값이 다르다. useState는 인자로 데이터 넘겨줄 때 아무런 가공없이 쌩으로 넘겨줬다. 하지만 리코일의 useRecoilState는 아톰이라는 형태로 데이터를 랩핑해서 넘겨준다. 가령 아래와 같다

```javascript
atom({
    key: '이_값은_유일해야_한다',
    default: '여기에_기본값을_입력',
});
```

위의 아톰을 보면 알겠지만 데이터에 키를 부여하는 것 뿐이다. 데이터를 가져올 때 어떤 데이터를 가져오는지 이름 정도는 알아야 할 것 아닌가? 키(key)는 데이터의 이름에 해당한다

#### Q. 데이터를 어디에서 가져오는가?

A. 데이터는 전역 스토어에서 가져온다. 이 전역 스토어는 리액트의 어떠한 컴포넌트에서도 참조할 수 있다. 따라서 데이터를 자식 컴포넌트로 계속 넘겨주는 프롭스 드릴링(props drilling)이 필요가 없다

#### Q. 어느 컴포넌트에서든지 상태를 전역스토어에서 가져올 수 있다고 했는데, 그 상태가 다른 컴포넌트에서  변경되면 그 변경사항을 어떻게 탐지하는가? 상태의 변경이 감지되면 컴포넌트가 재호출되어야 하는데 그런데 어떻게 그것이 가능한가?

A. 그건 컴포넌트가 상태를 구독하면 가능하다. 다른 컴포넌트가 값을 갱신할 때 이 갱신된 내용을 구독자 컴포넌트가 탐지한다. 컴포넌트가 변경사항을 탐지했으면 해당 컴포넌트 함수는 다시 호출된다. 그 구독은 셀렉터 함수를 통해서 이루어진다. 구체적으로 말하면 useRecoilValue라는 훅에 셀렉터 함수의 리턴값을 인자로 넣어주면 컴포넌트가 해당 셀렉터의 키(key)를 구독하게 된다.

#### Q. 정리하면 상태를 생성할 때는 아톰 함수로 생성하고 상태를 구독할 때는 셀렉터 함수로 구독하는 것인가?

A. 그렇다. 아톰과 셀렉터는 사용법이 거의 유사하다. 이들은 훅의 인자로 들어간다. 다시 말하면 아톰은 useRecoilState함수의 인자로 들어가고 셀렉터는 useRecoilValue의 인자로 들어간다. 이들 두 함수는 이름이 비슷하여 헷갈리기 쉽다. 조금 이해를 돕자면 useRecoilState는 중간의 Recoil이라는 글자만 제외하면 useState이다. useState 훅은 본래 상태를 생성하고 상태를 변경하는 함수다. useRecoilState도 마찬가지로 상태를 생성하고 상태를 변경한다. 즉 상태생성기라고 이해해도 좋다.\
반면 useRecoilValue는 중간의 Recoil이라는 단어만 제외하면 useValue이다. 이건 리액트의 기본 훅 중에서 대응할만한 훅이 없다. 그냥 값을 가져다 쓴다고 이해하자. 명백한건 useRecoilValue는 상태를 생성하는 역할은 아니며 그저 구독하는 역할이라는 점이다.\

#### Q. 다른 컴포넌트에서 생성한 상태를 가져오되, 상태까지 변경하고 싶으면 어떻게 하는가 ?

A. 상태를 가져오는건 useRecoilValue로 가져오고, 상태를 변경하고 싶으면 useSetRecoilState로 세터(setter)를 가져온다.\
사실 함수 이름이 너무 장황한데 단순하게 분류하면 useRecoilState는 `상태생성`, useRecoilValue는 `구독하기`이고 useSetRecoilState는 `상태변경하기`이다.

#### Q. 리코일은 useState의 대안인가?

A. 일부 그렇지만 완전한 대안은 아니다. `useState로 간단하게 끝날 수 있는 프로젝트`는 useState를 쓰는 것이 이상적이다\
useState를 권장하는 큰 이유는 다른 컴포넌트와 상태를 공유하지 않아도 되기 때문이다. 만일 상태를 자식 컴포넌트에게 건내주지 않는다면 하나의 컴포넌트가 상태를 독점해서 사용할 수 있다. 오해를 막기위해 첨언하면 이런 상황에서도 useState의 상태가 특정 컴포넌트에 귀속된 것은 아니다. useState의 상태는 리액트라는 컨텍스트에서 전역으로 관리된다. 그러니 하나의 컴포넌트에서 useState를 독점적으로 쓰고있는 상황을 `로컬 상태를 쓰고 있다고 말하기는 어렵다`.\
하지만 리액트 컨텍스트는 개발자가 아무렇게나 접근할 수 있는 영역이 아니다. 따라서 다른 컴포넌트에서 함부로 상태 참조가 불가능하므로 상태공유를 금기시하는 함수형의 관점에서 보면 `어느 정도`는 타당한 사용법이라고 볼 수 있다.\

#### Q. 다른 컴포넌트와 상태를 공유하지 않는 것이 왜 장점인가?

A. 함수가 예측가능한 형태로 실행되기 때문이다. 1번부터 100번까지의 컴포넌트가 하나의 상태를 공유하고 있다고 해보자. 그런 상황에서 1번 컴포넌트가 어떻게 렌더링될지 예측하는 것은 어렵다. 2번부터 100번까지의 다른 컴포넌트가 setState를 하는 순간 1번 컴포넌트는 다시 렌더링된다. 다시 말해 2번부터 100번까지의 다른 컴포넌트에 의해 1번 컴포넌트의 렌더링 방식이 결정된다. 만일 1번 컴포넌트의 상태가 예상치 못한 방식으로 렌더링이 되었다고 해보자. 즉 버그가 난것인데 이 버그의 원인을 어디서 찾을 것인가? 1번부터 100번 까지의 컴포넌트가 에러의 원인 후보에 오를 수 있다. 이런 상황에서 에러의 원인을 찾는 것은 고역이다. 사실 에러는 그 범위를 최대한 좁혀두고 찾는 것이 이상적이므로 디버깅의 관점에서 보면 컴포넌트간 상태를 공유하는 것은 지양해야 할 관례라고 할 수 있다

#### Q. useState를 권장하는 다른 이유가 있는가?

A. useState를 권장하는 이유는 단순한 사용법도 한 몫 한다. useState는 모든 상태관리 기법을 통틀어 사용법이 가장 단순하다. 단순한 방법으로 해결되는 상황이라면 굳이 복잡한 방법을 택할 이유는 없다. 만일 여러개의 컴포넌트간 상태를 공유하지 않는 상황이라면 useState만으로도 상태관리를 쉽게 할 수 있다. useState를 썻을 때 상태관리가 복잡해지는 상황은 여러 컴포넌트에서 하나의 상태를 공유할 때인데 이럴 때는 다른 상태관리 방법을 찾게 된다\

#### Q. 그러면 하나의 상태를 여러 컴포넌트가 공유한 상황에서 리코일은 어떻게 복잡성을 줄였나?\

A. 위에서 말했듯 두가지 컨셉으로 복잡성을 줄였다
1. 전역 스토어
1. 구독자-발행자 모델

전역 스토어는 거대한 전역 변수로 이해해도 좋다. 전역 스토어는 어떤 컴포넌트에서도 간단하게 상태를 참조할 수 있게 해준다. 전역 스토어에 접근할 때는 훅을 사용한다. 훅을 호출해서 전역 스토어의 값을 리턴받는 형식이다. 이런 방식은 일종의 자유변수를 참조하는 방식으로 해석할 수도 있다. 자유 변수는 함수 밖에서 선언된 변수를 뜻한다. 자유 변수는 함수의 일관된 작동을 저해하므로 권장되는 코딩 방법은 아니다. 하지만 복잡한 상태관리를 덜 복잡하게 구현하려면 자유변수 외에는 마땅한 솔루션이 없다\
자유 변수가 함수의 일관된 작동을 저해한다는 말이 이해가 가지 않는다면 `Q. 다른 컴포넌트와 상태를 공유하지 않는 것이 왜 장점인가?` 항목을 참조할것

# 이 문서는 작성중입니다

---

